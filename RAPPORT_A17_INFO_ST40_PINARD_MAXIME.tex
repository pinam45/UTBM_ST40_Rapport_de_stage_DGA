%!TEX program = xelatex
% not lualatex because of a pgf bug: https://sourceforge.net/p/pgf/bugs/384/
\PassOptionsToPackage{table,svgnames}{xcolor}
\documentclass[11pt, book, english, french, standardlists]{upmethodology-document}
\input{packages}
\input{settings}

\makeglossaries
\input{glossary}

\begin{document}
	\chapter*{Remerciements}
		\paragraph*{}
			Je tiens tout particulièrement à remercier mon maître de stage \textbf{Benoît Amiaux} pour m'avoir permis de travailler sur des sujets intéressants et formateurs. Je le remercie aussi pour le suivi et les conseils qu'il m'a apportés au cours du stage, ainsi que pour l'indépendance et la confiance qu'il m'a accordée.
		\paragraph*{}
			Ensuite, je tiens à remercier \textbf{les membres l'équipe VIM/VSE} pour leur accueil chaleureux, pour toutes les informations et les conseils qu'ils m'ont donnés ainsi que pour leur bonne humeur aux différentes pauses-café et repas.
		\paragraph*{}
			Je remercie aussi \textbf{la direction de la DGA} pour m'avoir permis de  joindre leur personnel durant ces quelques mois ainsi que \textbf{Laure Foissard} du Bureau de Gestion des Emplois et Compétences de la DGA et \textbf{Mireille Jacquot} du Service des Stages de l'UTBM pour la gestion de mon dossier.
	\tableofcontents{}
	\listoffigures{}
	\chaptertoc{Introduction}
		\paragraph*{}
			Le cursus à l'\gls{UTBM} est entrecoupé de deux périodes de stage de 6 mois durant les 3 ans du cycle ingénieur, après le Tronc Commun. La première, après un an en branche, est le ST40 intitulé ``Stage Assistant Ingénieur'' et la seconde, un an plus tard, est le ST50 intitulé ``Projet de fin d'études - Ingénieur débutant''.
		\begin{figure}[H]
			\centering%
			\resizebox{\textwidth}{!}{\import{figures/}{Cursus_INFO_UTBM.tex}}%
			\caption{Cursus en informatique a l'\acrshort{UTBM}}%
			\label{fig:Cursus_INFO_UTBM}%
		\end{figure}
		\paragraph*{}
			Ce rapport concerne mon ST40 que j'ai réalisé à la \gls{DGA} Maîtrise de l'Information sur le site de Bruz, près de Renne du 1er Aout 2017 au 26 Janvier 2018 sous la supervision de mon maitre de stage, Benoît Amiaux.
		\paragraph*{}
			La \gls{DGA} est une direction du Ministère des Armées qui a de nombreuses missions dont celle de préparer l'avenir des systèmes de défense français, en particulier sur le plan informatique avec son centre d'expertise et d'essais Maîtrise de l'Information. De ce fait, la \gls{DGA MI} est un acteur français important de la sécurité informatique. Ce dernier proposant un sujet intéressant qui correspondait à mes compétences, j'ai donc saisi l'opportunité d'y réalisé mon stage.
		\paragraph*{}
			Le sujet du stage implique de nombreux concepts bas niveau, ce qui m'intéresse particulièrement et m'a en partie poussé à choisir ce sujet, préférant travailler plus proche de la machine.  Le sujet est le développement et la fiabilisation d'un module de désassemblage \acrshort{MIPS} pour un débugger développé en interne. Le développement du module est en C/C++ et implique l'assemblage et le désassemblage de code, la gestion des adresses\ldots. Ainsi le sujet a l'avantage d'allier des concepts très bas niveau avec un développement dans des langages plus haut niveau.
		\paragraph*{}
			Je commencerai par présenter le Ministère des armées, la \gls{DGA} et la \gls{DGA MI}, j'expliciterai ensuite le sujet et l'organisation du stage avant de détailler le déroulement de ce dernier. Par la suite sera développé le travail réalisé sur le sujet initial ainsi que sur le sujet additionnel, ajouté au cours du stage.
	\chapter{Présentation de l'entreprise}
		\section{Le Ministère des Armées}
			\begin{upminfo}
				Nommé ``Ministère des Armées'' au début de la 5e république, il devient ``Ministère de la Défense nationale'' en 1969 puis ``Ministère de la Défense'' en 1974 avant de reprendre le nom de ``Ministère des Armées'' en 2017. Il est donc normal qu'il soit désigné par ``Ministère de la Défense'' dans les documents (Code de la défense, décrets\ldots) datant d'avant 2017.
			\end{upminfo}
			\subsection{Responsabilités}
				\paragraph*{}
					<<Le ministre de la défense est responsable de la préparation et de la mise en œuvre de la politique de défense. Il est en particulier chargé de l'infrastructure militaire comme de l'organisation, de la gestion, de la mise en condition d'emploi et de la mobilisation des forces armées et des formations rattachées[\ldots].
				\paragraph*{}
					Il a autorité sur les armées, les services de soutien, les organismes interarmées et les formations rattachées. Il veille à ce que ceux-ci disposent des moyens nécessaires à leur entretien, leur équipement et leur entraînement. Il est responsable de leur sécurité.
				\paragraph*{}
					Il est également chargé:
					\begin{itemize}
						\item de la prospective de défense;
						\item du renseignement extérieur et du renseignement d'intérêt militaire;
						\item de l'anticipation et du suivi des crises intéressant la défense;
						\item de la politique industrielle et de recherche et de la politique sociale propres au secteur de la défense.>>\cite{CodeDefenseL1142-1}
					\end{itemize}
			\subsection{Composition}
				\paragraph*{}
					<<L'administration centrale du ministère de la défense est composée:
					\begin{enumerate}
						\item De l'état-major des armées;
						\item Des organismes militaires et des services interarmées rattachés au chef d'état-major des armées;
						\item Des états-majors de l'armée de terre, de la marine et de l'armée de l'air;
						\item De la direction générale de l'armement;
						\item Du secrétariat général pour l'administration;
						\item De directions générales, directions et services.>>\cite{DEFD0918712D}
					\end{enumerate}
			\subsection{Budget}
				\paragraph*{}
					Le budget du Ministère de la défense vient de 3 crédits qui sont répartis sur trois missions:
					\begin{itemize}
						\item Défense
						\item Anciens combattants, mémoire et liens avec la Nation
						\item Recherche et enseignement supérieur au titre du programme Recherche duale
					\end{itemize}
				\paragraph*{}
					En 2017 le budget total est de 43,2 milliards d'euros, soit 13,6\% (10,2\% hors pensions) du budget total de l'État (détaillé sur la figure \ref{fig:Budget_Ministere_Defense_2017}). Dans le respect de la Loi de programmation militaire 2014-2019, de son actualisation en 2015 et des décisions prises à la suite des attentats de 2015 et de 2016, le budget de la mission ``Défense'' a été augmenté de 700 millions d'euros de 2015 à 2016 et de 600 millions d'euros de 2016 à 2017, le portant ainsi à 32,7 milliards d'euros.
				\begin{figure}[H]
					\centering%
					\includegraphics[width=1\textwidth]{Budget_Ministere_Defense_2017}
					\caption{Part du budget du Ministère de la Défense (pensions incluses) dans le budget général de l'État en 2017\cite{ChiffresDef2017}}%
					\label{fig:Budget_Ministere_Defense_2017}%
				\end{figure}
			\subsection{Effectifs}
				\paragraph*{}
					En 2016 le Ministère de la défense avait un effectif total de 265 458 \gls{ETPT}, composé à 77\% de militaires et 23\% de civils (voir détails sur la figure \ref{fig:Effectifs_Ministere_Defense_2016}). L'age moyen du personnel militaire était de 33,2 ans et celui du personnel civil de 47,4 ans.
				\begin{figure}[H]
					\centering%
					\resizebox{0.8\textwidth}{!}{\import{figures/}{Effectifs_Ministere_Defense_2016.tex}}%
					\caption*{\small\itshape Autres services = \acrshort{SCA}, \acrshort{SSA}, \acrshort{DGA}, \acrshort{SGA} (dont \acrshort{DICoD}), \acrshort{DIRISI}, \acrshort{SEA}, \acrshort{SIMu}, \acrshort{OIAS}, \acrshort{DRM}, \acrshort{DRSD}, \acrshort{DGSE}, \acrshort{DPID}, \acrshort{DGSIC}, \acrshort{DGRIS} et \acrshort{EMA} (partie centrale)}%
					\caption{Répartition des effectifs du Ministère de la Défense en 2016, par gestionnaire, en \acrshort{ETPT}\cite{ChiffresDef2017}}%
					\label{fig:Effectifs_Ministere_Defense_2016}%
				\end{figure}
		\section{La Direction générale de l'Armement}
			\subsection{Historique}
				\paragraph*{}
					En 1961, le général de Gaulle crée la \gls{DMA} pour rationaliser la construction des matériels militaires, elle compte 6 corps d'ingénieur militaires\footnote{Les ingénieurs militaires sont des experts techniques au service de la défense}: les ingénieurs de l'aéronautique, les ingénieurs militaires des fabrications d'armement, les ingénieurs du génie maritime, les ingénieurs hydrographes de la marine, les ingénieurs des poudres et les ingénieurs militaires des télécommunications. En 1968, ils sont remplacés par un corps unique: le corps des ingénieurs de l'armement. En 1977, la \acrshort{DGA-old} signifiant alors ``Délégation Générale pour l'Armement'' est créée pour remplacer la \gls{DMA}.
				\paragraph*{}
					En 1995, l'arrivée de Jean-Yves Helmer au poste de délégué général pour l'armement\footnote{Jean-Yves Helmer sera a la tête de la \acrshort{DGA-old} de 1996 à 2001} lancera un mouvement de regroupement et d'externalisation de la production industrielle. Regroupement d'une part par la fusion des implantations territoriales pour former 14 grands centres ainsi que la réduction du personnel qui passera de plus de 50 000 en 1995 à 9 700 en 2017. D'autre part externalisation car la \acrshort{DGA-old} passe d'une structure de production d'armement à une agence de maîtrise d'ouvrages complexes. Ainsi, la \acrshort{DGA-old} se séparera graduellement de ses activités industrielles.
					% \begin{itemize}
					% 	\item[1990] Le \gls{GIAT} de la \gls{DGA} devient la société anonyme \gls{GIAT} Industries (aujourd'hui Nexter System, détenu par l'État français)
					% 	\item[1991] La \gls{DCN} devient une société de droit privé à capitaux publics sous le nom de DCNS (aujourd'hui Naval Group, détenu à 62,49\% par l'État français)
					% 	\item[2000] Le \gls{SSF} est créé pour assurer dans une structure unique la maîtrise d'ouvrage de la mise en condition opérationnelle des bâtiments de surface et des sous-marins de la Marine nationale
					% 	\item[2007] Le \gls{SMA} est transféré à l'état-major de l'armée de l'air et renommé \gls{SIAé}
					% 	\item[2010] Le Centre d'Études de Gramat, responsable de l'évaluation des vulnérabilités des systèmes d'armes aux agressions des armes nucléaires et conventionnelles, est transféré au \gls{CEA}
					% \end{itemize}
				\paragraph*{}
					Le 5 octobre 2009, le décret n°2009-1180\cite{DEFD0918712D} officialise le changement de nom et d'organisation de la ``Délégation Générale pour l'Armement'' qui devient dès lors ``Direction Générale de l'Armement'', toujours abrégé \gls{DGA}.
			\subsection{Missions}
				\paragraph*{}
					La \gls{DGA} est une direction du Ministère des Armées, elle dépend non pas du Chef d'État-Major des Armées mais directement du ministre de la Défense. Elle a de très nombreuses missions (listées dans le décret n°2009-1180\cite{DEFD0918712D}, Article 1) dont on peut extraire trois missions principales:
				\p{Équiper les forces armées}
					Maître d'ouvrage des programmes d'armement, la \gls{DGA} est responsable de la conception, de l'acquisition et de l'évaluation des systèmes qui équipent les forces armées. Son action couvre toute la durée de vie de ces programmes.
				\p{Préparer l'avenir}
					Imaginer les futurs possibles, anticiper les menaces et les risques, préparer les capacités technologiques et industrielles, dans un cadre européen.
				\p{Promouvoir les exportations d'armement}
					Contribuer activement aux exportations d'armement tant sur l'aspect contrôle pour le respect des engagements internationaux de la France que sur l'aspect économique pour le développement des entreprises de défense.
			\subsection{Organisation}
				\paragraph*{}
					Depuis le 9 août 2017, Joël Barre est Délégué Général pour l'Armement (voir organigramme en \annexe{organigrammedga}), ce dernier, pour mener a bien les missions de la \gls{DGA}, s'appuie sur différents services (dont les attributions exactes sont détaillées dans le décret n°2009-1180\cite{DEFD0918712D}), organisés la plupart du temps sous forme matricielle:
				\p{Direction du Développement International} % décret n°2009-1180\cite{DEFD0918712D}, Article 6
					La \gls{DI} est chargée de la promotion des exportations d'armement en s'appuyant notamment sur le réseau des attachés d'armement. Elle anime et coordonne le soutien de l'État aux industriels exportateurs, en liaison étroite avec les états-majors et le réseau diplomatique.
				\p{Direction des opérations} % décret n°2009-1180\cite{DEFD0918712D}, Article 4
					La \gls{DO}\footnote{anciennement Direction des systèmes d'armes} est chargée de la conduite des programmes et opérations d'armement, et est chargée de l'exécution des travaux d'études en amont. La \gls{DO} est chargée de l'acquisition des systèmes d'armes, équipements de défense, matériels et logiciels en liaison avec les états-majors, et en assurant la cohérence entre les programmes.
				\p{Direction de la Stratégie} % décret n°2009-1180\cite{DEFD0918712D}, Article 5
					La \gls{DS}, à Bagneux, est en charge de la stratégie pour la recherche technologique, l'industrie, et les programmes d'armement menés en coopération en s'appuyant notamment sur la \gls{MRIS}.
				\p{Direction des Plans, des Programmes, et du Budget} % décret n°2009-1180\cite{DEFD0918712D}, Article 8
					La \acrlong{DP} (\acrshort{DP}\footnote{anciennement DPBG}) est chargée de la planification, de la programmation, de la préparation et de l'exécution du budget et assure la maîtrise financière et comptable des opérations d'armement conduites par la \gls{DGA}.
				\p{Services de soutien} % décret n°2009-1180\cite{DEFD0918712D}
					Le \gls{SMQ}, l'inspection, le \gls{COMM}, le \gls{SSDI}, la \gls{DRH}, la \gls{GArm}.
				\p{Direction Technique} % décret n°2009-1180\cite{DEFD0918712D}, Article 7
					La \gls{DT} assure les activités d'essai et d'expertise des matériels et des technologies militaires à l'aide de différents pôles de compétences. De nombreux centres d'expertise et d'essais interviennent dans le test des technologies de pointe, ces derniers sont dispersés sur toute la France (voir la figure \ref{fig:Carte_centres_expertise_et_essais_DGA}).
					\begin{figure}[H]
						\centering
						\includegraphics[width=0.9\textwidth]{Carte_centres_expertise_et_essais_DGA}
						\caption{Carte des centres d'expertise et d'essais de la \acrshort{DGA}\cite{OptroDefDGA}}
						\label{fig:Carte_centres_expertise_et_essais_DGA}
					\end{figure}
			\subsection{Effectifs et budget}
				\paragraph*{}
					En 2017 la \gls{DGA} a un effectif de 9 700 personnes dont plus de 51\% d'ingénieurs et cadres\cite{PresentationDGA}. Bien que membre à part entière du ministère de la Défense, la \gls{DGA} se distingue par une forte proportion de civils au sein de son personnel, 55,7\% pour la \gls{DGA} contre une moyenne de 22,9\% pour le Ministère de la Défense dans son ensemble en 2015\cite{ChiffresDef2016}, mais aussi par la quasi-absence de sous-officiers, aucun pour la \gls{DGA} contre une moyenne de 44,9\% pour le Ministère de la Défense dans son ensemble en 2016\cite{ChiffresDef2017}.
				\paragraph*{}
					Le budget de la \gls{DGA} n'est pas public, mais représente une part conséquente du budget du Ministère de la défense pour pouvoir maintenir, en 2017, 80 programmes d'armement et maintenir sa position de premier investisseur public de France, avec près de 11 milliards d'euros de commandes passées pour la seule année 2017. De plus la \gls{DGA} maintient une présence internationale dans 20 pays, y compris auprès de l'\gls{OTAN} et de l'\gls{UE}\cite{PresentationDGA}.
		\section{La DGA Maîtrise de l'Information}
			\subsection{Historique}
				\paragraph*{1961}
					<<Un conseil interministériel présidé par Georges Pompidou décide de favoriser le développement de l'économie de la Bretagne en y encourageant l'implantation de l'industrie électronique. Au détriment du choix initial de Grenoble, Rennes doit devenir le second pôle de l'électronique en France derrière Paris.>>\cite{CELAR40ansAvenir}
				\paragraph*{1964}
					% L'ingénieur militaire en chef de 1ère classe des télécommunications Émile Rombout est chargé de diriger les opérations de création du centre.
					La décision est prise de créer le \gls{CELAR}. <<Le cahier des charges précise que le terrain aura une superficie de 15 à 30 hectares, à 15 km de Rennes maximum. Il bénéficiera de vues dégagées, sera éloigné de sources de perturbations radioélectriques et sera attractif comme un terrain déjà planté en arbres tel un parc à l'instar des autres centres d'études et de recherche récemment implantés.>>\cite{CELAR40ansAvenir}
				\paragraph*{1966}
					Début de construction du \gls{CELAR} sur un terrain de 108 hectares situé à Bruz. <<Le coût total de l'opération est estimé à 41 millions de francs dont 25 millions à la charge de la \gls{DATAR} et 16 millions à celle du ministère des Armées>>\cite{CELAR40ansAvenir}
				\paragraph*{1968}
					Ouverture du \gls{CELAR}, les deux premières années l'activité technique du \gls{CELAR} consiste essentiellement en des travaux de simulation et d'évaluation de matériels.
				\paragraph*{1970-1980}
					Le \gls{CELAR} étend ses activités, accueille le \gls{CCSA} et développe ses capacités de conseil. Le \gls{CELAR} investit dans le domaine la guerre électronique et des systèmes spatiaux.
				\paragraph*{1980-1990}
					Les simulations numériques et hybrides prennent leur essor. L'analyse technologique des composants électroniques se renforce. En 1986, est instauré le \gls{SCSSI}\cite{DecretCreationSCSSI} dont la conséquence sera la scission de la \gls{SSI} en France entre le secteur commercial prit en charge par le Ministère des Télécommunications et le secteur gouvernemental prit en charge par le Ministère de la Défense. Les premières actions relevant de la \gls{SSI} au \gls{CELAR} sont des travaux dans le domaine des évaluations des produits de chiffrement gouvernementaux.
				\paragraph*{1990-2000}
					À l'issue de la guerre du Golfe, le \gls{CELAR} est désigné comme le centre technique de la \gls{DGA} pour la guerre électronique. Il développe ses compétences pour la sécurité des systèmes d'information. En 1993, \gls{CCSA} disparaît pour laisser place au \gls{CASSI}. <<L'approche est singulière dans le contexte du moment qui jusque-là a une tendance lourde a repousser vers le secteur privé toutes les activités alors industrielles de l'État. Pour la \gls{SSI}, il s'agit en effet de rapatrier en sphère étatique les activités alors industrielles de production des algorithmes cryptographiques gouvernementaux, de réalisation des composants cryptographiques et de définition des équipements de chiffrement.>>\cite{CELAR40ansAvenir} % Toujours en 1993, une première machine est installée sur le réseau internet, c'est une station SUN sous Unix.
				\paragraph*{2000-2010}
					Le \gls{CELAR} devient le centre de référence européen des techniques de la guerre de l'information, dans un contexte des systèmes pour une sécurité globale. Les effectifs \gls{SSI} se multiplient face au besoin de sécurisation de tous les ministères. <<Par ailleurs, les systèmes d'armes font une entrée massive dans la zone d'action de la \gls{SSI}. [\ldots] Les torpilles, avions, chars et missiles sont désormais dotés de capacités de calcul, de stockage et d'échange d'informations, tout comme les machines informatiques classiques.>>\cite{CELAR40ansAvenir}\\
					En 2005 le \gls{CELAR} se réorganise en six divisions:
					\begin{itemize}
						\item \acrfull{CGN}
						\item \acrfull{SSI}
						\item \acrfull{MC}
						\item \acrlong{ASC}\footnote{Commandement, Communication, Conduite et Renseignement} (\acrshort{ASC})
						\item \acrfull{SDS}
						\item \acrfull{SM}
					\end{itemize}
					En 2009 le \gls{CELAR} est renommé en \acrfull{DGA MI}, son patrimoine brut est alors évalué à plus de 323 millions d'euros.
				\p{2010-2018}
				\noindent\vspace{-7mm}
					\begin{upmcaution}
						Au sein de la \gls{DGA} et de nombreux projets classé secrets se déroulent sur plus de 10 ans, il n'est donc pas possible de diffuser des informations relatives à l'évolution de la \gls{DGA MI} sur ces dernières années.
					\end{upmcaution}
			\subsection{Missions}
				\paragraph*{}
					La \gls{DGA MI} est un centre d'expertise technique de la \gls{DGA} qui a pour mission:
					\begin{itemize}
						\item L'aide à la spécification d'architecture de systèmes et ingénierie des systèmes
						\item Expertise et évaluation de l'utilisation du spectre des fréquences
						\item Expertise des réseaux de télécommunication et des systèmes de transmission
						\item Spécification, évaluation et validation de l'interopérabilité des systèmes de commandement et de communication
						\item Spécification et évaluation des systèmes de renseignement (capteurs spatiaux, drones\ldots)
						\item Évaluation de la sécurité des systèmes d'information, conception et évaluation de produits de sécurité
						\item Évaluation des performances de systèmes d'armes, de guerre électronique et de guerre optronique
						\item Expertise des systèmes de missiles tactiques et stratégiques
						\item Expertise de composants électroniques spécifiques pour la défense
					\end{itemize}
			\subsection{Organisation}
				\begin{upminfo}
					L'organisation de la \gls{DGA MI} est Diffusion Restreinte, c'est-à-dire qu'elle n'est pas classée secrète mais qu'elle porte une mention particulière de confidentialité, tout élément d'organisation ne concernant pas le stage ne sera donc pas abordé.
				\end{upminfo}
				\paragraph*{}
					Pour mon stage, j'ai rejoint les départements \gls{VIM/VSE} au sein de la division \gls{SSI}5. Les départements \gls{VIM/VSE} ont été créés en 2017, les deux équipes se connaissant bien et partageant le même étage ainsi que la même salle de pause, j'ai donc autant côtoyé la partie VIM que VSE.
				\begin{figure}[H]
					\centering
					\resizebox{\textwidth}{!}{\import{figures/}{Hierarchie_DGA_MI_a_VIM.tex}}
					\caption{Hiérarchie de la \acrshort{DGA MI} à \acrshort{VIM/VSE}}
					\label{fig:Hierarchie_DGA_MI_a_VIM}
				\end{figure}
				\paragraph*{}
					Un schémas plus complet reprenant la hiérarchie des Ministères français à VIM/VSE est disponible en \annexe{hierarchieministereavim}.
		\section{Le secret}
			\subsection{Classification}
				\paragraph*{}
					<<Les informations et supports classifiés font l'objet d'une classification comprenant trois niveaux:
					\begin{enumerate}
						\item Très Secret-Défense;
						\item Secret-Défense;
						\item Confidentiel-Défense.>>\cite{CodeDefenseR2311-2}
					\end{enumerate}
				\paragraph*{}
					<<Le niveau Très Secret-Défense est réservé aux informations et supports qui concernent les priorités gouvernementales en matière de défense et de sécurité nationale et dont la divulgation est de nature à nuire très gravement à la défense nationale.
				\paragraph*{}
					Le niveau Secret-Défense est réservé aux informations et supports dont la divulgation est de nature à nuire gravement à la défense nationale.
				\paragraph*{}
					Le niveau Confidentiel-Défense est réservé aux informations et supports dont la divulgation est de nature à nuire à la défense nationale ou pourrait conduire à la découverte d'un secret de la défense nationale classifié au niveau Très Secret-Défense ou Secret-Défense.>>\cite{CodeDefenseR2311-3}
				\paragraph*{}
					Les documents qui ont fait l'objet de mesures de classification au niveaux cité précédemment relèvent de l'article 413-9 du Code Pénal\cite{CodePenal413-9}.
				\paragraph*{}
					<<Nul n'est qualifié pour connaître des informations et supports classifiés s'il n'a fait au préalable l'objet d'une décision d'habilitation et s'il n'a besoin, selon l'appréciation de l'autorité d'emploi sous laquelle il est placé, au regard notamment du catalogue des emplois justifiant une habilitation établi par cette autorité, de les connaître pour l'exercice de sa fonction ou l'accomplissement de sa mission.>>\cite{CodeDefenseR2311-7}
			\subsection{Diffusion Restreinte}
				\paragraph*{}
					<<Certaines informations qu'il n'y a pas lieu de classifier peuvent cependant recevoir, de la part de leur émetteur, une marque de confidentialité destinée à restreindre leur diffusion à un domaine spécifique [\ldots] ou à garantir leur protection (telle que Diffusion Restreinte).
				\paragraph*{}
					Ces mentions, qui ne traduisent pas une classification, ne suffisent pas à conférer aux informations concernées la protection pénale propre au secret de la défense nationale. Leur seul objectif est de sensibiliser l'utilisateur à la nécessaire discrétion dont il doit faire preuve dans la manipulation des informations couvertes par cette mention.
				\paragraph*{}
					L'auteur de la divulgation, qu'il relève de la sphère publique ou de la sphère privée, s'expose à des sanctions disciplinaires ou professionnelles, sans préjudice de l'application éventuelle des dispositions spécifiques au traitement et à la protection de données à caractère personnel.
				\paragraph*{}
					La mention Diffusion Restreinte [\ldots] indique que l'information ne doit pas être rendue publique et ne doit être communiquée qu'aux personnes ayant besoin de la connaître dans l'exercice de leurs attributions.>>\cite{PRMD1132480A}
			\subsection{Application au stage}
				\paragraph*{}
					Les projets des départements \gls{VIM/VSE} sont souvent classifiés au niveau Confidentiel-Défense. Cela implique donc des règles de sécurité très strictes et un cloisonnement des projets. Toujours pour des raisons de sécurité, les règles de sécurité, moyens de cryptage utilisés, vérification des données et autres systèmes de sécurité mis en place ne pourront pas être détaillés dans ce rapport.
				\paragraph*{}
					La liste des membres des équipes, l'organigramme de la division ou encore activités exactes menées sont soit Diffusion Restreinte soit classé secrètes. Cependant les travaux réalisés par \gls{VIM/VSE} impliquent souvent l'analyse de binaires dont le code source est inconnu, pour cela des outils externes tel que IDA de Hex-Rays sont utilisés mais aussi des outils internes dont GenDbg, un débogueur générique et YaCo, un plugin qui permet le travail collaboratif avec IDA.
				\paragraph*{}
					Durant mon stage, j'ai justement travaillé sur ces outils internes (GenDbg et YaCo) dont les informations ne sont ni classées secrètes ni Diffusion Restreinte. GenDbg a été présenté publiquement au \gls{SSTIC} de 2008\cite{SSTICGenDbg} et YaCo à celui de 2017\cite{SSTICYaCo}. %Les membres de l'équipe travaillent sur différentes missions mais ont une partie de leur temps de travail dédié au développement des outils dont ils peuvent avoir besoin tels que GenDbg et YaCo.
	\chapter{Organisation du stage}
		\section{GenDbg}
			\subsection{Présentation}
				\paragraph*{}
					Il existe une multitude d'architectures matérielles et des langages et chaque environnement de développement logiciel intègre un outil de débogage plus ou moins évolué. De ce fait, les outils de débogage ne cessent de se multiplier. GenDbg est un débogueur développé et utilisé en interne à la \gls{DGA MI} depuis plus de 10 ans, il a pour but de proposer une solution générique, cohérente et évolutive à ce problème.
				\paragraph*{}
					Le projet présente trois grands avantages:
					\begin{itemize}
						\item \textbf{Maîtrise}: contrôle de tous les aspects du cycle de vie logiciel et indépendance vis-à-vis de tout éditeur de logiciels
						\item \textbf{Modularité}: constitué d'un cœur et d'une multitude de modules pour permettre un enrichissement fonctionnel très rapide et facilement paramétrable
						\item \textbf{Généricité}: certainement le principal intérêt du projet, il est possible d'exécuter pas-à-pas un programme quel que soit son mode d'exécution sur n'importe quelle plate-forme et n'importe quel système d'exploitation
					\end{itemize}
				\paragraph*{}
					GenDbg permet de déboguer tout type de programme (code machine, byte code java, P-Code visual basic, DotNet,\ldots) sur des architectures hétérogènes. Pour cela, il adopte un modèle framework / stub qui permet de séparer les composants débogués et la machine de l'analyste. En fonction du type d'analyse envisagé (malware) on préférera travailler sur deux machines physiques distinctes. Cette approche avec des stubs permet aussi de réduire l'empreinte du débogueur sur la cible. Le framework est capable de communiquer avec les stubs via un port série ou des canaux nommés (pipes).
				\paragraph*{}
					Les modules obligatoires au fonctionnement de GenDbg sont le stub, le framework, le module ASM (module de désassemblage) et le \gls{GUI}\footnote{interface graphique}. Historiquement seul un \gls{GUI} en ``mode texte'' était disponible mais une seconde interface, graphique cette fois, et réalisée avec Qt fut développé plus tard. Une vue de Gendbg utilisant le GUI Qt ainsi que sa lecture est présente en \annexe{guiqtgendbg} ainsi que la lecture de la vue Code en \annexe{guiqtgendbgvuecode}.
				\begin{figure}[H]
					\centering
					\resizebox{\textwidth}{!}{\import{figures/}{GenDbg_architecture_minimale.tex}}
					\caption{GenDbg: Architecture minimale}
					\label{fig:GenDbg_architecture_minimale}
				\end{figure}
				\paragraph*{}
					Concrètement, et en utilisant les notations de la figure \ref{fig:GenDbg_architecture_minimale}, pour exécuter un programme pas-à-pas avec GenDbg, il faut:
					\begin{itemize}
						\item Sur l'ordinateur 1:\\
							Exécuter le stub correspondant à l'architecture de l'ordinateur avec en paramètre le programme a analyser ainsi que le canal de communication a utiliser. Le stub se chargera de lancer l'application.
						\item Sur l'ordinateur 2:\\
							Spécifier le canal de communication à utiliser dans le fichier de configuration de GenDbg puis exécuter le framework. Le framework se chargera des récupérer les informations nécessaires du stub, tel que le module ASM a utiliser et chargera le \gls{GUI}, permettant d'exécuter l'application pas-à-pas.
					\end{itemize}
				\paragraph*{}
					L'ordinateur 1 pouvant être une machine différente de l'ordinateur 2, ou bien la même machine, ou encore une machine virtuelle.
			\subsection{Fonctionnement}
				\p{Le framework}
					C'est la partie centrale de GenDbg, c'est une application Win32 qui prend en charge la communication inter-modules, implémente le jeu de commandes de base commun à l'ensemble des modules ainsi que le moteur de script historique. Le moteur de script historique est maintenant très peu utilisé puisque des bindings Python sont  disponibles et utilisables dans une console Python intégré au \gls{GUI} Qt, permettant de scripter directement en Python dans GenDbg.
				\paragraph*{}
					<<Tous les modules sont implémentés sous forme de librairies dynamiques et sont chargés dans l'espace d'adressage du framework après identification de la cible par un stub.
				\paragraph*{}
					Le framework a en charge la lecture d'un fichier de configuration (.ini) pour tenter d'établir un canal de communication avec un stub et l'initialisation des différents modules. Dans l'état actuel du projet le framework est capable de communiquer avec les stubs via un port série ou des canaux nommés (pipes). Il est ainsi possible de déboguer aussi bien des machines physiques que des machines virtuelles (VMWare ou VirtualPC) en mappant un port série virtuel sur un canal nommé.
				\paragraph*{}
					Le framework fournit aux différents modules un jeu de fonctions de base qui vont permettre d'interagir entre eux.>>\cite{SSTICGenDbg}
				\p{Les stubs}
					<<Les stubs s'exécutent sur la machine cible et prennent en charge la gestion des exceptions sur l'architecture cible; à ce titre ils sont fortement dépendants de l'architecture et de l'OS de la cible. Les stubs fournissent les services de base au framework, c'est-à-dire les accès en lecture et en écriture aux registres et à la mémoire. Ils réalisent aussi l'identification précise de la cible pour le framework, l'identification conduisant au chargement des modules utiles et disponibles.>>\cite{SSTICGenDbg}
				\p{Les modules ASM}
					<<Les modules ASM sont en fait des dés-assembleurs/assembleurs prenant en charge la représentation du code, des données et des adresses propres à l'architecture cible. Par exemple sur l'architecture IA32, en mode virtuel protégé une adresse mémoire est de la forme ``\jcode{sélecteur:offset}'' avec le sélecteur sur 16 bits et l'offset sur 32 bits. C'est le module ASM IA32 qui a la charge de la représentation visuelle d'une adresse virtuelle.>>\cite{SSTICGenDbg}
				\p{Les modules additionnels}
					En plus des modules obligatoires, un certain nombre de modules spécifiques optionnels sont définis:
					\begin{itemize}
						\item \textbf{Les Command Modules}:\\
							Ils complètent les commandes de base implémentées dans le framework avec des commandes spécifiques au contexte d'exécution de la cible.
						\item \textbf{Les OS Helper Modules}:\\
							Ils offrent des services et des fonctionnalités propres à un système d'exploitation parmi lesquelles la signalisation d'un certain nombre d'événements internes.
						\item \textbf{Les Breakpoint Helpers Modules}:\\
							Ils permettent la prise en charge et la définition de points d'arrêt spécifiques à l'architecture cible.
						\item \textbf{Les Symbol Modules}:\\
							Ils permettent d'associer un symbole à une adresse particulière dans un module de l'OS cible.
					\end{itemize}
					Ces modules ne sont pas concernés par le stage et n'ont pas été utilisés, ils ne seront pas plus détaillés dans ce rapport.
				\p{Modularité et généricité}
					De par son architecture (représentée sur la figure \ref{fig:GenDbg_modules}) GenDbg déplace les spécificités hors du framework, les spécificités d'architecture et d'OS à déboguer se trouvent donc au niveau des stubs tandis que celles dues à la représentation (instructions, adresses\ldots) se trouvent au niveau des modules ASM. De même toutes les fonctionnalité spécifiques supplémentaires se trouvent au niveau des modules additionnels. Cela permet d'avoir un framework générique qui n'a pas besoin d'être modifié pour étendre les fonctionnalités de GenDbg. Cela permet aussi d'avoir un développement très ciblé, pour développer un nouveau module, il est seulement nécessaire de connaître l'\gls{API} que GenDbg expose aux modules et l'\gls{API} que le module expose à GenDbg.
				\p{Implémentation}
					Le framework est écrit en C, mais de par l'architecture modulaire, ne restreint pas le langage d'écriture des stubs et modules, le \gls{GUI} Qt est par exemple lui en C++. Dans les faits la plupart des stubs et modules sont, eux aussi, écrit en C. Certains stubs sont implémentés nativement d'autres le sont sous la forme de ``wrapper'' qui réalisent la traduction du protocole GenDbg vers le protocole d'un autre débogueur (par exemple gdb\footnote{Débogueur standard du projet GNU} et jdb\footnote{Débogueur Java de Oracle}).
				\begin{figure}[H]
					\centering
					\resizebox{\textwidth}{!}{\import{figures/}{GenDbg_modules.tex}}
					\caption{L'architecture modulaire du framework de GenDbg}
					\label{fig:GenDbg_modules}
				\end{figure}
			\subsection{Gestion du projet}
				\paragraph*{}
					Le projet n'étant pas une mission de la division mais un outil interne, son développement s'est étalé sur de nombreuses années et beaucoup de personnes ont travaillé dessus, souvent sur de courtes durées, sur les heures allouées au développement des outils internes.
				\paragraph*{}
					L'intégralité du code (framework, modules et stubs) est géré avec le gestionnaire de version Git, mais, pour des raisons de sécurité, il n'y a pas de serveur avec un repo synchronisé, ce dernier est passé par support physique entre les développeurs.
				\paragraph*{}
					La compilation est gérée avec CMake qui peut générer le projet pour différentes cibles (le plus souvent Visual Sudio) permettant de compiler le projet. Toutes les dépendances sont contenues dans le projet et compilées avec, à l'exception de Qt qui doit être installé sur la machine pour compiler le \gls{GUI} Qt.
				\paragraph*{}
					Il n'y a pas de normes de documentation, cette dernière est très peu présente en dehors des \gls{API} exposées par GenDbg et les modules. Il n'y avait, avant le stage, pas de tests, ceux que j'ai ajoutés sont gérés et exécutés avec CMake et utilisent la librairie \gls{GTest}.
			\subsection{Travail a réaliser}
				\paragraph*{}
					Le but initial du stage était le développement et la fiabilisation d'un module de désassemblage basé sur la librairie Capstone pour les architectures \acrshort{MIPS} et PowerPC. Le développement nécessitant d'implémenter toutes les fonctionnalités d'un module ASM GenDbg dont l'assemblage et le désassemblage en réalisant l'interfaçage entre GenDbg et Capstone. La fiabilisation elle, nécessitant la réalisation et la validation de tests unitaires sur les modules développés.
				\begin{figure}[H]
					\centering
					\resizebox{\textwidth}{!}{\import{figures/}{GenDbg_modules_impl.tex}}
					\caption{Implémentation des modules GenDbg et librairies utilisées}
					\label{fig:GenDbg_modules_impl}
				\end{figure}
				\paragraph*{}
					Lorsqu'il est évoqué d'utiliser la librairie Capstone, c'est en réalité la librairie Capstone et Keystone qui sont concernées, la première réalisant le désassemblage et la deuxième l'assemblage de code pour de nombreuses architectures, elles seront abordées plus en détail dans le chapitre \ref{ch:gendbg}. Certains modules utilisent déjà des librairies, c'est le cas des modules x86 et AMD64 qui utilisent déjà Capstone et Keystone. Les librairies étant déjà présentes, elles sont déjà intégrées au système de compilation, il suffira d'ajouter la liaison aux modules \acrshort{MIPS} et \acrshort{PPC} lors de leur compilation.
				\paragraph{}
					Le travail à réaliser est donc très technique et ne requiert pas d'étude préalable des cas d'utilisation ou d'identification des besoins, la conception du logiciel, son architecture et les différentes \gls{API} étant déjà présente et non modifiables au cours du stage. Il sera nécessaire d'étudier les différentes \gls{API} utilisables (GenDbg et Capstone) pour réalisé l'\gls{API} demandée (module ASM) tout en s'assurant de l'évolutivité du module.
				\paragraph*{}
					Le stage a commencé par la réalisation du module pour l'architecture \acrshort{MIPS} (détaillé au chapitre \ref{ch:gendbg}). À la fin de la réalisation de ce dernier cependant il fut décidé qu'il serait plus intéressant de ne pas réaliser le module pour l'architecture \acrshort{PPC}, pour à la place travailler sur le projet YaCo. %(présenté dans la section suivante et détaillé au chapitre \ref{ch:yaco}).
		\section{YaCo}
			\subsection{Présentation}
				\p{IDA}
					IDA\footnote{pour Interactive disassembler (désassembleur interactif)} Pro est un désassembleur commercial très utilisé en rétro-ingénierie. Il prend en charge de nombreux formats exécutables pour différents processeurs et systèmes d'exploitation. Il peut également être utilisé comme débogueur pour les exécutables \acrshort{Windows PE}, Mac OS X Mach-O et Linux \acrshort{ELF}. Pour un coût supplémentaire, un plugin de décompilation pour les programmes compilés avec un compilateur C/C++ est disponible.
				\paragraph*{}
					IDA effectue une analyse automatique du code, en utilisant des références croisées entre les sections de code, la connaissance des paramètres des appels d'\gls{API} et d'autres informations. Cependant, la nature du désassemblage empêche une précision totale et une intervention humaine importante est nécessaire. Un utilisateur IDA classique commencera par une base de code générée automatiquement, puis convertira les sections du code en données et vice versa, renommera, annotera et ajoutera d'autres informations à la base, jusqu'à ce que le comportement du programme devienne clair. (Le GUI d'IDA en vue texte et en vue graphe est visible dans l'\annexe{ida7gui}.)
				\paragraph*{}
					IDA permet donc de comprendre le fonctionnement d'un programme en analysant manuellement un binaire après une première analyse automatique. Un problème apparait lorsque l'ont veut réaliser cela sur des grosses bases de code, cela devient compliqué, voire impossible, de réaliser une analyse seul en un temps raisonnable, or IDA ne permet pas de travailler à plusieurs sur la même base de code.
				\begin{figure}[H]
					\centering
					\resizebox{\textwidth}{!}{\import{figures/}{YaCo_principe.tex}}
					\caption{Principe de YaCo}
					\label{fig:YaCo_principe}
				\end{figure}
				\p{YaCo}
					YaCo\footnote{pour Yet another collaborative tool} est un plugin pour IDA développé en interne a la \gls{DGA MI}, puis rendu publique au \gls{SSTIC} de 2017\cite{SSTICYaCo} et publié sur GitHub\cite{GithubYaCo}, il a pour but de résoudre ce problème en permettant un travail collaboratif sur la même base de code en utilisant le gestionnaire de version Git (voir figure \ref{fig:YaCo_principe}).
			\subsection{Fonctionnement}
				\paragraph*{}
					IDA, à partir du binaire à analyser, génère une base de code sur laquelle il réalise une première analyse automatique avant que l'utilisateur ne travaille dessus. Cette base de code est contenue dans un fichier \gls{IDB} dans un format propriétaire, YaCo ne peut donc pas utiliser ou modifier l'\gls{IDB} sans passer par IDA, pour cette raison YaCo est implémenté comme un plugin et non un logiciel externe.
				\paragraph*{}
					Les \gls{IDB} ne sont pas dans un format textuel et donc une simple utilisation de Git sur l'\gls{IDB} génèrerait un dépôt Git très lourd et ne permettrait pas de gérer les merges lorsque 2 personnes modifient en parallèle la base, or le but premier de YaCo est de permettre de travailler à plusieurs sur une même base.
				\begin{figure}[H]
					\centering
					\resizebox{\textwidth}{!}{\import{figures/}{YaCo_fonctionnement.tex}}
					\caption{YaCo: fonctionnement}
					\label{fig:YaCo_fonctionnement}
				\end{figure}
				\paragraph*{}
					La solution choisit pour résoudre ce problème (représenté sur la figure \ref{fig:YaCo_fonctionnement}) est de gérer un dépôt Git en parallèle de l'\gls{IDB} utilisé par l'instance d'IDA, qui contiendrait l'\gls{IDB} original (après la première analyse d'IDA mais avant que l'utilisateur n'ait commencé à utiliser la base) ainsi que les modifications faites par l'utilisateur par rapport à cet \gls{IDB} original dans un format \gls{XML}, donc textuel et facilement utilisable avec Git.
				\begin{figure}[H]
					\centering
					\resizebox{0.7\textwidth}{!}{\import{figures/}{YaCo_git_usage.tex}}
					\caption{YaCo: utilisation de Git}
					\label{fig:YaCo_git_usage}
				\end{figure}
				\paragraph*{}
					Ainsi, comme représenté sur la figure \ref{fig:YaCo_git_usage}, le premier commit ajoute l'\gls{IDB} original et les commits suivants ajoutent et modifient eux les fichiers \gls{XML} des modifications incrémentales par rapport à l'\gls{IDB} original. Le fait de garder les modifications séparées dans un format textuel permet à YaCo de gérer les conflits Git entre les modifications de plusieurs utilisateurs qui modifient en parallèle la base.
				\paragraph*{}
					YaCo était initialement implémenté en Python mais, pour des raisons de maintenabilité et de performances, une conversion vers le C++ a été initiée. Afin que les parties déjà portées en C++ soient utilisables depuis le Python le logiciel \gls{SWIG} est utilisé.
				\paragraph*{}
					\gls{SWIG} est un outil logiciel open source, permettant de connecter des logiciels ou bibliothèques logicielles écrites en C/C++ avec des langages de script tel que le Python en créant des bindings pour ce dernier.
				\paragraph*{}
					Pour faire un plugin IDA, il suffit de placer un fichier Python contenant une fonction \jcode{PLUGIN\_ENTRY} dans le dossier \folder{plugins} de l'installation IDA. Cette fonction doit retourner une classe qui implémente \jcode{plugin\_t}, les fonctions de cette classe permettant d'initialiser, lancer et arrêter le plugin.
				\paragraph*{}
					Outre ce fichier (\file{yaco\_plugin.py}), YaCo est composé de plusieurs éléments principaux implémentés en 2 langages.\\
					En Python:
					\begin{itemize}
						\item le plugin: lancement, arrêt, ajout des menus au \gls{GUI} de IDA
						\item la gestion des évènements IDA
						\item la gestion du dépôt Git
					\end{itemize}
					En C++:
					\begin{itemize}
						\item l'import / export entre IDA et les fichiers de modification \gls{XML}
					\end{itemize}
				\paragraph*{}
					Chacun de ces éléments utilise l'\gls{API} de IDA, disponible en C++ et en Python, ainsi que les bindings \gls{SWIG} pour réaliser sa tâche.
			\subsection{Gestion du projet}
				\paragraph*{}
					Le projet, tout comme GenDbg, n'est pas une mission de la division mais un outil qu'ils développent pour être utilisé dans le cadre de leurs missions. Ce dernier, comme GenDbg, est public puisque présenté au \gls{SSTIC}\cite{SSTICYaCo} mais est aussi utilisable par tous et open-source puisque publié sur GitHub\cite{GithubYaCo}.
				\paragraph*{}
					Cela implique une gestion plus stricte du projet puisque la version en ligne doit, si possible, toujours compiler et fonctionner pour la dernière version d'IDA et qu'il a été décidé de ne pas modifier l'historique Git, rendant chaque commit du dépôt GitHub définitif.
				\paragraph*{}
					Cependant, cela apporte l'avantage d'avoir des retours utilisateurs et des rapports de bugs (issues sur GitHub) afin d'améliorer et maintenir YaCo. Un autre avantage est que tout le monde peut proposer des correctifs et améliorations, permettant au projet d'être développé par des personnes extérieures à la \gls{DGA}.
				\paragraph*{}
					De la même façon que pour GenDbg, la compilation est gérée avec CMake. De nombreux tests sont présents sur le projet, à la fois des tests unitaires sur certaines parties mais aussi des tests d'intégration afin de tester le comportement global de YaCo.
			\subsection{Travail a réaliser}
				\paragraph*{}
					Mon travail sur Yaco a été de continuer le portage en C++ du plugin tout en améliorant le code pour les parties toujours en Python, les principales étant la gestion les évènements IDA et du dépôt Git. En effet le plugin est le résultat d'un développement incrémental selon les besoins du moment, de nombreuses améliorations du code sont possibles.
				\paragraph*{}
					Ce portage en C++ va donc permettre de repenser le code dans sa globalité alors que lors du développement initial incrémental le but était plutôt d'ajouter la fonctionnalité nécessaire le plus vite possible en modifiant le moins de code possible, générant des redondances de code ainsi que la présence de code qui n'est plus utilisé.
				\paragraph*{}
					Les \gls{API} C++ et Python de GenDbg étant différentes sur de nombreux points, il ne sera pas possible de se baser sur l'utilisation de cette dernière faite dans le Python et il sera nécessaire d'étudier l'\gls{API} C++.
				\paragraph*{}
					Enfin, durant mon portage en C++, Hex-Rays a sorti la version 7 de IDA dans laquelle ils ont modifié l'\gls{API} aussi bien Python que C++, le portage a donc aussi été l’occasion de porter YaCo sur IDA 7.
		\section{Déroulement du stage}
			\subsection{Conditions de travail}
				\p{Horaires}
					Mes horaires de travail pendant le stage étaient 8h30 -- 16h45, mais ces dernières n'étaient pas strictes et il m'était possible de rester plus tard pour compenser en cas de retard le matin ou simplement pour finir quelque chose avant de partir. La pause de midi était de 45 minutes et en général l'équipe se réunissait dans le couloir pour aller manger ensemble au restaurant d'entreprise.
				\p{Badge et zones}
					Le site de la \gls{DGA MI} est très sécurisé et un badge est nécessaire pour entrer et se déplacer sur le site, le badge donne accès au site, mais est aussi nécessaire pour accéder aux bureaux. J'ai obtenu mon badge assez tardivement (voir figure \ref{fig:Planning}), avant son obtention, j'avais un badge visiteur ne me permettant pas d'avoir accès à un bureau mais une solution temporaire a vite été trouvée et j'ai rapidement pu commencer à travailler.
				\p{Accès internet}
					Toujours dans un but de sécurité, les postes de travail ne sont reliés a aucun réseau afin de limiter leurs interactions avec des données étrangères. L'accès à internet se fait donc par un poste dédié qui est simplement une machine Windows avec uniquement un navigateur internet et un montage logiciel et réseau permettant de s'assurer de la sécurité de la connexion. Une fois le badge obtenu et un bureau attribué, j'ai été équipé d'un poste dédié pour accéder à internet.
				% \p{Logiciels}
				% 	Pour travailler sur GenDbg et YaCo, il m'était indispensable d'avoir CMake, git, Python, Hex-Rays IDA et un environnement de développement C/C++. J'ai travaillé durant la totalité du stage sous Windows 10 avec Microsoft Visual Studio 2017 et Sublime Text 3. En plus des logiciels indispensables cités avant j'ai aussi utilisé plusieurs outils de visualisation graphique pour Git. % + VirtualBox, QEMU Alpine Linux, Debian MIPS, TeXLive pour la présentation...
			\subsection{Planning}
				Voir figure \ref{fig:Planning}.
				\begin{landscape}
					\begin{figure}[H]
						\vspace*{-0.5cm}
						\hspace*{-2cm}
						\centering
						\resizebox{1.2\paperwidth}{!}{\import{figures/}{Planning.tex}}
						\caption{Planning}
						\label{fig:Planning}
					\end{figure}
				\end{landscape}
				\paragraph*{}
					Comme visible sur la figure \ref{fig:Planning}, j'ai commencé par le travail sur GenDbg avec le développement du module \acrshort{MIPS} et de ces tests, j'ai ensuite testé le module sur une utilisation réelle tout en effectuant les modifications et corrections nécessaires. Par la suite, à partir de mi Octobre, j'ai commencé à travailler sur YaCo en commençant par le Repository et en continuant sur les Hooks.
				\paragraph*{}
					Lors de mon travail plusieurs code review\footnote{revues de code} ont été réalisées par mon maître de stage, ce dernier m'indiquant des corrections et améliorations a réalisé dans mon code. Je suis donc parfois retourné travailler sur le travail précédant afin d'appliquer les modification demandées dans la revue de code.
				\paragraph*{}
					Enfin, le travail sur YaCo a donné lieu a deux pull request\cite{GithubYaCoPR24,GithubYaCoPR30} sur le dépôt publique du projet sur GitHub\cite{GithubYaCo}.
				\paragraph*{}
					Après avoir terminé le travail sur GenDbg et YaCo, j'ai préparé une présentation orale interne à la \gls{DGA MI} sur le contenu de mon stage qui a eu lieu le 23 Janvier 2018 et a duré une quarantaine de minutes. Les 3 jours restants après la présentation, j'ai travaillé sur des améliorations mineures sur YaCo.
	\chapter{GenDbg}\label{ch:gendbg}
		\section{L'architecture MIPS}
			\subsection{Présentation}
				\paragraph*{}
					L'\gls{ISA} \gls{MIPS} est une architecture de processeurs de type \gls{RISC} développée par la société MIPS Technologies. La première version de l'\gls{ISA}, \gls{MIPS} I a été publié en 1985, ont ensuite suivi de nombreuses autres versions pour arriver, en 2017, aux versions actuelles qui sont ``MIPS32/64 Release 6'' et leurs extensions ``microMIPS32/64 Release 6'' (voir figure \ref{fig:MIPS_Architecture_Evolution}).
					\begin{figure}[H]
						\centering
						\includegraphics[width=0.8\textwidth]{MIPS_Architecture_Evolution}
						\caption{Évolution de l'architecture \acrshort{MIPS}\cite{MIPS32Arch}}
						\label{fig:MIPS_Architecture_Evolution}
					\end{figure}
				\paragraph*{}
					Les processeurs fabriqués selon cette architecture ont surtout été utilisés dans les systèmes SGI\footnote{société américaine qui construisait des stations de travail dédiées à l'infographie, la 3D, le traitement vidéo et le calcul haute performance}. On les retrouve aussi dans plusieurs systèmes embarqués, comme les ordinateurs de poche, les routeurs Cisco et les consoles de jeux vidéo (Nintendo 64 et Sony PlayStation, PlayStation 2 et PSP).
				\paragraph*{}
					Vers la fin des années 1990, on estimait que les processeurs dérivés de l'architecture \gls{MIPS} occupaient le tiers des processeurs \gls{RISC} produits. De nos jours cette architecture reste populaire dans le marché de l'informatique embarquée où elle subit une intense concurrence de la part de l'architecture ARM.
			\subsection{Particularités}
				\paragraph*{}
					\gls{MIPS} est une architecture de type ``load / store''\footnote{également appelée ``register-register''} (chargement / stockage), c'est-à-dire qu'à l'exception des instructions de chargement et stockage utilisées pour accéder à la mémoire, toutes les instructions opèrent sur les registres.
				\paragraph*{}
					Les registres \gls{MIPS} ont une taille de 32 bits et sont répartis comme suit:
					\begin{itemize}
						\item 32 \gls{GPR} noté de \reg{0} à \reg{31}
							\begin{itemize}
								\item \reg{0} est câblé à zéro et les écritures sont ignorées
								%\item \reg{31} est le registre de liens
							\end{itemize}
						\item 3 \gls{SPR}
							\begin{itemize}
								\item \reg{HI} et \reg{LO} contiennent le résultat des opérations de multiplication et de division
								\item \reg{PC} est le compteur de programme
							\end{itemize}
					\end{itemize}
				\paragraph*{}
					Pour récupérer les résultats des multiplications et divisions, un petit jeu d'instructions permet de copier des données entre les \gls{GPR} et les registres \reg{HI} et \reg{LO}. Les deux bits de poids faible de \reg{PC} sont toujours à 0 puisque les instructions \gls{MIPS} ont une longueur de 32 bits et sont toujours alignées.
				\paragraph*{}
					Une autre particularité du \gls{MIPS} est le ``delay slot'', c'est une instruction qui se trouve après un branchement, mais qui sera exécutée que le branchement soit pris ou non (dans le cas de branchement conditionnel). Certaines instructions ont un comportement indéfini lorsque placées dans le delay slot.
				\paragraph*{}
					Ce comportement vient du fait que l'instruction après un branchement a déjà été chargée dans le pipeline par le processeur. La Release 6 supprime les delay slot mais ajoute un concept de ``forbidden slot''. Ces particularités (delay slot / forbidden slot) n'impactent pas le module, elles ne seront donc pas plus détaillées, mais elles sont importantes à prendre en compte lors du débogage de code MIPS.
			\subsection{Backward-compatibilité}
				\paragraph*{}
					L'\gls{ISA} MIPS32 est conçue pour les processeurs 32 bits, les registres ont donc une longueur de 32 bits tandis que l'\gls{ISA} MIPS64 est conçue pour les processeurs 64 bits, les registres ont donc une longueur de 64 bits. La particularité est que, que ce soit en MIPS32 ou en MIPS64, les instructions restent sur 32 bits cela permettant au MIPS64 d'être backward-compatible avec le MIPS32.
				\paragraph*{}
					Le module ASM développé a été conçu pour le MIPS64 ainsi que le MIPS32 mais, de par cette propriété, à partir du MIPS64 le support du MIPS32 a demandé très peu d'effort.
			\subsection{Coprocesseurs}
				\paragraph*{}
					Une particularité du \gls{MIPS} est qu'il supporte jusqu'à quatre coprocesseurs (CP0/1/2/3). Dans la terminologie \gls{MIPS}, CP0 est le coprocesseur de contrôle du système, CP1 est une \gls{FPU} et CP2/3 sont des coprocesseurs optionnels définis par l'implémentation. Par exemple, dans la console PlayStation, CP2 est le \gls{GTE}, qui accélère le traitement de la géométrie dans les graphiques 3D.
				\paragraph*{}
					Chaque coprocesseur possède des instructions particulières, celles du CP0 et du CP1 étant supportées par Capstone, le module les supporte aussi. Pour les coprocesseurs spécifiques définis par l'implémentation, et non supportés par Capstone, ils ne seront pas traités durant ce stage.
			\subsection{Documentation}
				\paragraph*{}
					Le module développé durant le stage a pour but de supporter les \gls{ISA} MIPS32 et MIPS64 dans la majorité de leurs versions. Les versions de 1 à 5 ne présentent pas d'incompatibilités entre elles et ne sont que des évolutions / extensions des versions précédentes. La version 6 quant à elle modifie des instructions et en supprime d'autres par rapport la version 5, elle présente donc des incompatibilités.
				\paragraph*{}
					Les documentations utilisées seront les volumes de ``MIPS® Architecture For Programmers'' mis à disposition par Imagination Technologies LTD.\\
					Pour le MIPS32:
					\begin{itemize}
						\item Volume I-A: Introduction to the MIPS32® Architecture\cite{MIPS32Arch}
						\item Volume II-A: The MIPS32® Instruction Set Manual, Revision 6.05\cite{MIPS32InstrSet605}
						\item Volume II-A: The MIPS32® Instruction Set Manual, Revision 5.04\cite{MIPS32InstrSet504}
					\end{itemize}
					Pour le MIPS64:
					\begin{itemize}
						\item Volume I-A: Introduction to the MIPS64® Architecture\cite{MIPS64Arch}
						\item Volume II-A: The MIPS64® Instruction Set Reference Manual, Revision 6.05\cite{MIPS64InstrSet605}
						\item Volume II-A: The MIPS64® Instruction Set Reference Manual, Revision 5.04\cite{MIPS64InstrSet504}
					\end{itemize}
				\paragraph*{}
					Ces documentations contiennent toutes les informations sur l'\gls{ISA} \gls{MIPS} ainsi que le descriptif de chaque instruction et son encodage (voir figure \ref{fig:MIPS_Description_instruction_ADD}). Ces informations permettent de coder un assembleur / désassembleur du langage, cette partie du module est gérée avec Capstone, mais le décodage manuel des instructions a parfois été nécessaire, notamment pour les tests.
					\begin{figure}[H]
						\centering
						\fbox{\includegraphics[width=\textwidth]{MIPS_Description_instruction_ADD}}
						\caption{Extrait de la documentation \acrshort{MIPS}: Description de l'instruction ADD\cite{MIPS64InstrSet605}}
						\label{fig:MIPS_Description_instruction_ADD}
					\end{figure}
		\section{Compilation}
			\subsection{Le système en place}
				\paragraph*{}
					CMake est une famille d'outils multiplateformes et open-source conçus pour compiler, tester et déployer des logiciels. CMake est utilisé pour contrôler la compilation d'un logiciel en utilisant des fichiers de configuration indépendants de la plate-forme et du compilateur à partir desquels seront générés des makefiles et projets pour de nombreux IDE et compilateurs.
				\paragraph*{}
					Le système de compilation et de tests de GenDbg utilise CMake pour ne dépendre d'aucune plateforme ou compilateur particulier, pour cela un fichier (\file{CMakeLists.txt}) définit plusieurs cibles pour CMake. Chaque cible correspond a un ou plusieurs fichiers de sortie (\acrshort{DLL}, exécutable\ldots). Les principales cibles sont:
					\begin{itemize}
						\item Le framework (\file{GenDbg.exe}), c'est l'exécutable principal
						\item Les modules, une cible par module (\file{AsmModuleMIPS.dll}, \file{OSHelper\_AMD64.dll}, \ldots)
						\item Les stubs, une cible par stub (\file{JAVAStub.exe}, \file{VBoxStub.exe}, \ldots)
						\item Le dépendances, une cible par dépendance (\file{Capstone.dll}, \file{Keystone.dll}, \ldots)
					\end{itemize}
				\paragraph*{}
					Afin que l'installation de GenDbg se suffise à elle-même et qu'il ne soit pas nécessaire d'installer préalablement des librairies ou logiciels nécessaires au fonctionnement de GenDbg, toutes les dépendances sont incluses dans le projet et compilées en même temps que ce dernier. La seule exception est Qt pour le \gls{GUI} dont l'incorporation et le maintien à jour du système de compilation auraient demandé trop de travail.
				\paragraph*{}
					Un autre avantage non négligeable de gérer directement les dépendances plutôt que se reposer sur l'installation de ces dernières par l'utilisateur est le contrôle de la version utilisée. Si, par exemple, la dernière version de la librairie Capstone change l'\gls{API} ou contient un bug, cela permet d'avoir le temps de modifier GenDbg en conséquence avant de mettre à jour la librairie.
				\paragraph*{}
					Me concernant durant le stage, j'utilisais CMake pour générer un projet Visual Studio 2017 qui me servait à développer le module et à compiler GenDbg.
			\subsection{Les interdépendances}
				\paragraph*{}
					En plus de dépendre parfois d'une ou plusieurs dépendances externes, le framework, les modules et les stubs, puisque communicants ensembles, dépendent de définitions et donc de fichiers communs. Un schéma simplifié représentant les dépendances entre éléments de GenDbg développés et utilisés durant le stage est disponible en \annexe{gendbgdependancescompilationsimplifiees}.
				\paragraph*{}
					Les fichiers de code source de chaque module ou stub sont regroupés dans un dossier, basiquement la compilation d'un module ou stub revient à compiler tous les fichiers de ce dossier, mais il faut ajouter à cela les fichiers en commun. Le principal fichier commun est \file{GenDbg.h}, il contient toutes les définitions des types communs qui sont utilisés pour la communication avec le framework tel que \jclass{MemoryAddress\_T} ou \jclass{ViewCtx\_T}.
				\paragraph*{}
					Chaque type de module (ASM, OS helper, \ldots) a une \gls{API} a implémenter qui sera utilisée par le framework. La définition de cette \gls{API} est donc commune entre tous les modules d'un même type et le framework. Ainsi, le framework et le module ASM \acrshort{MIPS} que j'ai développé ont en commun, en plus de \file{GenDbg.h}, le fichier \file{AsmModule.h} qui définit l'\gls{API} des modules ASM.
				\paragraph*{}
					Le framework étant générique, il n'a pas à connaître les informations spécifiques à l'architecture déboguée. Cependant, les modules ASM et les stubs manipulent eux directement des informations relatives aux registres du processeur débogué, le stub par les requêtes de lecture et écriture de ces derniers et le module ASM par l'assemblage / désassemblage des instructions. Ils ont donc besoin de dénominations communes, concrètement dans GenDbg pour chaque architecture de processeur une enum avec tous les registres du processeur sert à les identifier. Pour l'architecture \acrshort{MIPS} cette enum est contenue dans les fichiers \file{Mips.h} et \file{Mips64.h}.
				\paragraph*{}
					Les fichiers contenant des définitions nécessaires au développement du module sont donc:
					\begin{itemize}
						\item \file{GenDbg.h}: types communs
						\item \file{AsmModule.h} \gls{API} des modules ASM
						\item \file{Mips.h} et \file{Mips64.h}: enum des registres MIPS
					\end{itemize}
					Ces derniers seront utilisés sans être modifiés afin de garder l'\gls{API} de GenDbg et des composants MIPS inchangée.
			\subsection{Ajout du module}
				\paragraph*{}
					L'ajout du module a été assez simple puisque l'ancien module \acrshort{MIPS} étant présent, la configuration de CMake pour sa compilation était, elle aussi, déjà présente. Il a suffi de supprimer ce dernier pour le remplacer par une implémentation, initialement vide de l'\gls{API} des modules ASM pour que le nouveau module compile.
				\paragraph*{}
					Les librairies Capstone et Keystone étant déjà présentes pour les modules x86 et AMD64, je n'ai eu qu'à les ajouter en dépendances du module \acrshort{MIPS} pour que celles-ci lui soient lié à la compilation. Ces dernières sont liées statiquement pour ne pas avoir à gérer des \acrshort{DLL} externes desquelles dépendrait le module.
			\subsection{Ajout des tests}
				\paragraph*{}
					GTest est un framework de tests unitaires pour le C++, basé sur une architecture xUnit\footnote{désigne les frameworks de tests qui ont une structure semblable à SUnit, conçut par Kent Beck en 1998}, \gls{GTest} est open-source et multi plateforme. Il permet de réaliser des tests unitaires sans modification des sources du projet, son utilisation est très répandue pour les projets C et C++.
				\paragraph*{}
					Les tests du module utilisent \gls{GTest}, j'ai donc téléchargé les sources de \gls{GTest}\cite{GithubGTest} et les ai ajouté aux dépendances. Les dépendances de GenDbg sont toutes placées dans le répertoire \folder{deps}, chacune dans un dossier nommé \file{<nom de la dépendance>-<version>}.
				\paragraph*{}
					YaCo a lui aussi pour dépendance \gls{GTest}, pour ce qui est de la compilation je n'ai donc eu qu'à isoler et reprendre la partie du script CMake de YaCo qui gère la compilation de \gls{GTest} et l'adapter pour GenDbg. J'ai ensuite ajouté \gls{GTest} en dépendance du module \acrshort{MIPS} pour qu'il lui soit lié à la compilation.
				\paragraph*{}
					J'ai décidé de différencier les fichiers contenant les tests en les nommant avec le suffixe \file{\_test}, pour ajouter la cible des tests à CMake, je prend donc la liste des fichiers du module et retire ceux ne finissant pas par \file{\_test}. J'ajoute ensuite une cible de test avec comme sources les fichiers filtrés et comme dépendance le module ASM et \gls{GTest}.
				\paragraph*{}
					La cible génère un fichier exécutable avec la fonction \jfunc{main} définie par \gls{GTest} qui va réaliser les tests que j'ai spécifiés et retourner 0 en cas de réussite ou un code d'erreur en cas d'échec des tests. Les tests pourront alors être lancés avec CTest (utilitaire de test de CMake) qui va exécuter le test et en cas d'échec afficher l'output du test.
		\section{Fonctionnement}
			\subsection{API}
				\paragraph*{}
					Les modules ASM exposent une \gls{API} minimale composée d'une seule fonction:\\
					\lstinputlisting[language={[gendbg]C}, style=magic_style, numbers=none]{code/GetAsmModuleInfo.c}
					Cette fonction retourne simplement la structure \jclass{AsmModuleInfo\_T} allouée statiquement dans le module qui contient toutes les informations nécessaires à l'utilisation du module:
					\begin{itemize}
						\item version du module (2)
						\item architecture (MIPS)
						\item taille de cellule (8 bits)
						\item taille max d'une instruction (32 bits)
						\item type de données utilisées (byte, halfword, word, doubleword)
						\item groupes de registres (\gls{GPR}32, \gls{GPR}64, \gls{SPR}32, \ldots)
						\item \ldots
						\item liste des fonctions de rappel du module
					\end{itemize}
				\paragraph*{}
					Le détail de la structure est disponible en \annexe{detailasmmoduleinfot}, la structure contient de nombreuses informations nécessaires au framework pour identifier le module, mais ce qui sert à utiliser le module c'est la liste des fonctions de rappel (callback en anglais).
				\paragraph*{}
					Les fonctions de rappel sont les fonctions ``exportées'' par le module, celles qui réalisent les fonctionnalités du module. Toutes les fonctions ne seront pas abordées dans la suite du rapport, la liste complète des fonctions de rappel du module est présente en \annexe{fonctionsrappelmodulesasm}. On peut les regrouper en trois grands groupes qui seront abordés dans les sections suivantes:
					\begin{itemize}
						\item Gestion du module
						\item Manipulation des données
						\item Conversion des données
					\end{itemize}
			\subsection{Gestion du module}
				\paragraph*{}
					Les différents modules de GenDbg ainsi que le framework ``exportent'' des fonctions qui prennent toutes en premier paramètre un pointeur non typé, il pointe sur le contexte / l'instance du module, ce dernier contient les informations privées du module qui permettent son fonctionnement sans utiliser de variables globales pour sauvegarder son état.
				\paragraph*{}
					Généralement, les modules ASM sauvegardent dans leur contexte les fonctions de rappel et le contexte du framework, ainsi que le dernier message d'erreur qui peut ensuite être récupéré par le framework avec la fonction \jfunc{GetLastErrorMsg}. Dans le cas du module \gls{MIPS}, sera aussi conservé dans le contexte les contextes de Capstone et Keystone.
				\paragraph*{}
					La première fonction que le framework doit appeler avant de commencer à utiliser le module est \jfunc{Init}. Par cette fonction le framework donne au module un pointeur sur son contexte ainsi qu'un tableau de pointeur sur ses fonctions de rappel utilisables par le module. Ces dernières sont gardées dans le contexte du module et permettent de demander des informations au framework qui se chargera d'obtenir les informations par le stub par exemple.
				\begin{figure}[H]
					\centering
					\resizebox{0.9\textwidth}{!}{\import{figures/}{GenDbg_diagramme_sequence_initialisation.tex}}
					\caption{GenDbg: Séquence d'initialisation}
					\label{fig:GenDbg_diagramme_sequence_initialisation}
					\vspace{-0.5cm}
				\end{figure}
				\paragraph*{}
					La figure \ref{fig:GenDbg_diagramme_sequence_initialisation} représente la séquence d'initialisation du module, le framework commence par récupérer les informations du programme débogué auprès du stub, puis, pour chaque module ASM il récupère sa structure \jclass{AsmModuleInfo\_T}, compare l'architecture du module avec celle fournie par le stub jusqu'à trouver le module adapté. Une fois le module ASM adapté trouvé, il appelle sa fonction \jfunc{Init} explicité précédemment et récupère son contexte.
				\paragraph*{}
					Les fonctions du module ont alors en leur possession tous les éléments nécessaires à la réalisation de leur tache: Capstone et Keystone pour l'assemblage et le dé-assemblage, et les fonctions de rappel du framework pour accéder aux informations du programme débogué.
				\paragraph*{}
					À la fin de l'exécution de GenDbg, le framework appelle la fonction \jcode{Uninit} qui se charge de libérer la mémoire utilisée par le module et de supprimer son contexte.
			\subsection{Manipulation des données}
				\paragraph*{}
					Les fonctions de manipulation des données existent principalement dans le but de garder le framework générique, pour cela le framework ne peut pas réaliser de traitement spécifique à une architecture. La manipulation des données spécifiques à une architecture telles que les registres et les adresses mémoires est donc réalisée par l'intermédiaire du module ASM qui lui, tout comme le stub, est spécifique à l'architecture.
				\begin{figure}[H]
					\centering
					\resizebox{\textwidth}{!}{\import{figures/}{GenDbg_sequence_GetInstructionPointer.tex}}\\
					\vspace{5pt}
					\resizebox{0.85\textwidth}{!}{\import{figures/}{GenDbg_sequence_legend.tex}}
					\caption{GenDbg: séquence d'appels pour la récupération du pointeur d'instruction}
					\label{fig:GenDbg_sequence_GetInstructionPointer}
				\end{figure}
				\paragraph*{}
					Prenons l'exemple de la fonction \jcode{GetInstructionPointer}, comme illustré sur la figure \ref{fig:GenDbg_sequence_GetInstructionPointer}, cette dernière permet au framework de récupérer l'adresse de l'instruction courante au format MIPS, inconnu du framework, en restant générique, sans avoir eu à manipuler les structures spécifiques à l'architecture déboguée.
				\paragraph*{}
					Le module utilise la fonction \jfunc{ReadRegister} exposé par le framework pour demander aux stubs de lire la valeur du registre \reg{PC}, le framework lui se contente de réaliser la communication entre le module et le stub par le protocole GenDbg (protocole utilisé pour communiquer avec les stubs). Le stub, connaissant les structures MIPS, lit le registre demandé par le module ASM, puis retourne la valeur au module par l'intermédiaire du framework, finalement le module ASM converti la valeur en adresse MIPS.
			\subsection{Conversion des données}
				\paragraph*{}
					Les fonctions de conversion des données sont celles qui permettent de convertir l'information du format spécifique à l'architecture (opaque au framework) vers une représentation textuelle pour l'affichage utilisateur et l'opération inverse lorsque l'utilisateur rentre de l'information (en paramètre d'une fonction dans la console par exemple). Ces fonctions vont donc souvent par deux, par exemple \jfunc{AddressToTxt} et \jfunc{TxtToAddress}.
				\begin{figure}[H]
					\centering
					\resizebox{\textwidth}{!}{\import{figures/}{GenDbg_sequence_AddressToTxt.tex}}\\
					\vspace{5pt}
					\resizebox{0.85\textwidth}{!}{\import{figures/}{GenDbg_sequence_legend.tex}}
					\caption{GenDbg: séquence d'appels pour la conversion d'adresse en texte}
					\label{fig:GenDbg_sequence_AddressToTxt}
				\end{figure}
				% \begin{figure}[H]
				% 	\centering
				% 	\resizebox{\textwidth}{!}{\import{figures/}{GenDbg_sequence_TxtToAddress.tex}}\\
				% 	\vspace{5pt}
				% 	\resizebox{0.85\textwidth}{!}{\import{figures/}{GenDbg_sequence_legend.tex}}
				% 	\caption{GenDbg: séquence d'appels pour la conversion de texte en adresse}
				% 	\label{fig:GenDbg_sequence_TxtToAddress}
				% \end{figure}
				\paragraph*{}
					Elles permettent de convertir une adresse MIPS vers sa représentation textuelle et inversement, cela permet d'afficher les adresses dans le \gls{GUI} comme visible dans l'\annexe{guiqtgendbgvuecode}.
			\subsection{Utilisation de Capstone et Keystone}
				\paragraph*{}
					Les fonctions d'assemblage et de désassemblage font partie des fonctions de conversion des données mais celles-ci sont les plus complexes à implémenter et représentent la majeure différence avec l'ancien module MIPS de par l'utilisation de Capstone et Keystone.
				\p{Information basiques}
					Capstone, dans son utilisation la plus simple prend en entrées une ou plusieurs instructions au format binaire et retourne ces instructions au format textuel. Keystone quant à lui réalise l'inverse, il prend en entrées une ou plusieurs instructions au format textuel et retourne ces instructions au format binaire. Cet usage de Capstone et Keystone est fait pour les fonctions \jfunc{UnassembleBloc} et \jfunc{AssembleSingle}.
				\begin{figure}[H]
					\centering
					\resizebox{\textwidth}{!}{\import{figures/}{Capstone_Keystone_utilisation_basique.tex}}
					\caption{Utilisation basique de Capstone et Keystone}
					\label{fig:Capstone_Keystone_utilisation_basique}
				\end{figure}
				\paragraph*{}
					\jfunc{AssembleSingle} sert pour certains appels des consoles utilisateur classique et Python qui peuvent permettre d'assembler du code et d'aller écrire le code assemblé dans la mémoire du programme débogué.
				\begin{figure}[H]
					\centering
					\resizebox{\textwidth}{!}{\import{figures/}{GenDbg_sequence_UnassembleBloc.tex}}\\
					\vspace{5pt}
					\resizebox{0.85\textwidth}{!}{\import{figures/}{GenDbg_sequence_legend.tex}}
					\caption{GenDbg: séquence d'appels pour le désassemblage d'instructions}
					\label{fig:GenDbg_sequence_UnassembleBloc}
				\end{figure}
				\paragraph*{}
					\jfunc{UnassembleBloc} est utilisée pour afficher les instructions dans la vue code du GUI (visible dans l'\annexe{guiqtgendbgvuecode}), cette fonction est donc souvent appelée et a un grand impacte sur les performances. Capstone est très optimisé cela profite donc au module qui pourra aussi profiter des prochaines améliorations de Capstone sans avoir à changer son code.
				\paragraph*{}
					Ces informations basiques de Capstone et Keystone peuvent être traitées sans différenciation en fonction de l'architecture, toutes les informations sont contenues dans la structure \jclass{cs\_insn} (voir \annexe{structurescapstone}), c'est-à-dire que l'on peut appliquer un traitement des informations identique pour toutes les architectures. Cela permettrait donc un traitement unique qui pourrait être utilisé pour tous les modules ASM.
				\p{Informations détaillées}
					Pour Keystone on se limitera aux informations basiques, Capstone quant à lui peut être utilisé pour récupérer de nombreuses informations détaillées sur l'instruction désassemblée. Dans le module ASM, c'est la fonction \jfunc{GetInstructionInfo} qui utilise Capstone pour fournir des informations sur l'instruction au framework.
				\paragraph*{}
					Certaines de ces informations telle que la taille de l'instruction ne seront pas utiles (les instructions sont toujours sur 32 bits en MIPS) mais d'autres permettront d'afficher des informations supplémentaires sur les instructions à l'utilisateur, par exemple dans le \gls{GUI} Qt:
					\begin{itemize}
						\item les instructions de saut non conditionnel sont affichées en rouge (figure \ref{fig:GenDbg_GUI_Qt_Vue_code_Instruction_saut_non_conditionnel})
						\item les instructions de saut (conditionnel ou non) ont en commentaire une flèche qui indique la direction du saut (figures \ref{fig:GenDbg_GUI_Qt_Vue_code_Instruction_saut_non_conditionnel} et \ref{fig:GenDbg_GUI_Qt_Vue_code_Instruction_saut_conditionnel})
						\item les instructions avec des références mémoire ont en commentaire l'adresse mémoire référencée et la valeur stockée à cette adresse (figure \ref{fig:GenDbg_GUI_Qt_Vue_code_Instruction_ecriture_memoire})
					\end{itemize}
				\begin{figure}[H]
					\centering%
					\fbox{\includegraphics[width=1\textwidth]{GenDbg_GUI_Qt_Vue_code_Instruction_saut_non_conditionnel}}
					\caption{GUI Qt de Gendbg: vue code, instruction de saut non conditionnel}%
					\label{fig:GenDbg_GUI_Qt_Vue_code_Instruction_saut_non_conditionnel}%
				\end{figure}
				\begin{figure}[H]
					\centering%
					\fbox{\includegraphics[width=1\textwidth]{GenDbg_GUI_Qt_Vue_code_Instruction_saut_conditionnel}}
					\caption{GUI Qt de Gendbg: vue code, instruction de saut conditionnel}%
					\label{fig:GenDbg_GUI_Qt_Vue_code_Instruction_saut_conditionnel}%
				\end{figure}
				\begin{figure}[H]
					\centering%
					\fbox{\includegraphics[width=1\textwidth]{GenDbg_GUI_Qt_Vue_code_Instruction_ecriture_memoire}}
					\caption{GUI Qt de Gendbg: vue code, instruction d'écriture mémoire}%
					\label{fig:GenDbg_GUI_Qt_Vue_code_Instruction_ecriture_memoire}%
				\end{figure}
				\paragraph*{}
					Le problème de l'utilisation des informations détaillées de Capstone est que le format de ces informations est spécifique à l'architecture. Elles sont contenues dans la structure \jclass{cs\_detail} (voir \annexe{structurescapstone}) qui est différenciée pour chaque architecture a l'aide d'une union. Les informations relatives à l'architecture MIPS se trouvent donc dans la structure \jclass{cs\_mips} (voir \annexe{structurescapstone}). Cela empêche un traitement unifié des informations détaillées pour plusieurs architectures.
			\subsection{Tests unitaires}
				\paragraph*{}
					Les tests unitaires du module ont été développés en parallèle de ce dernier afin de tester les fonctionnalités au fur et à mesure de leur implémentation, cela m'a permis de trouver très tôt de nombreux bugs potentiels du module et des comportements anormaux de Capstone et Keystone.
				\paragraph*{}
					Les tests ont été réalisés avec \gls{GTest} qui ne nécessite pas de modifier le code du programme testé, permettant de garder les tests séparés du module. Les tests se déroulent dans une ``fixture'', c'est un environnement qui permet d'exécuter des tests, de réaliser des actions avant chaque test.
				\paragraph*{}
					J'ai donc conçu une fixture qui reproduit le comportement du framework et fournit au module ASM un contexte et des fonctions de rappel qui simulent le framework afin de réaliser un exécutable de test indépendant, ne nécessitant pas de lancer un stub et le framework comme pour une utilisation classique de GenDbg.
				\paragraph*{}
					De plus j'ai conçut les tests de façon à garder les données des tests séparées du traitement des tests. Pour cela toutes les données à tester sont placées dans des tableaux de données de test. Ces tableaux permettent d'étendre simplement un test en ajoutant des lignes au tableau des données de test sans avoir à modifier le fonctionnement du test en lui-même.
				\paragraph*{}
					Cette conception m'a permis de tester les fonctions pour de très nombreuses valeurs, en particulier les fonctions d'assemblage et de désassemblage avec des instructions au format binaire et textuel généré à la main à partir de la documentation. Tester ces fonctions revient à tester Capstone et Keystone, j'ai donc trouvé quelques bugs sur ces derniers mais il a suffi de remplacer les versions actuelles utilisées par GenDbg par les dernières versions pour corriger la majorité de ces bugs.
				\paragraph*{}
					Les tests étant externes au module j'ai aussi pu appliquer ces derniers sur l'ancien module, ce dernier échoue à plusieurs tests, notamment l'assemblage, le désassemblage et les tests avec des valeurs erronées et pointeur nuls qui ne sont pas vérifiés par le module.
		\section{Tests d'utilisation}
			\subsection{Montage}
				\paragraph*{}
					Afin de tester le module dans un cas d'utilisation réel sans avoir en ma possession une machine équipé d'un processeur MIPS, j'ai utilisé l'émulateur QEMU avec lequel j'ai fait fonctionner le système d'exploitation Debian pour l'architecture MIPS. QEMU n'est pas le seul émulateur capable d'exécuter des programmes et systèmes d'exploitation pour de nombreuses architectures dont MIPS mais il a l'avantage de pouvoir exposer un serveur gdb permettant de déboguer le programme exécuté via \acrshort{HTTP} avec le protocole de gdb.
				\begin{figure}[H]
					\centering
					\resizebox{1.05\textwidth}{!}{\import{figures/}{GenDbg_montage_test_manuels.tex}}
					\caption{GenDbg: Montage utilisé pour les tests manuels}
					\label{fig:GenDbg_montage_test_manuels}
				\end{figure}
				\paragraph*{}
					Ainsi, comme représenté sur la figure \ref{fig:GenDbg_montage_test_manuels}, en utilisant le stub GdbWrapperStub qui permet de se connecter à un serveur gdb et le framework avec le \gls{GUI} Qt et le module ASM \gls{MIPS} j'ai été en mesure de tester en conditions réelles le module entièrement en local sur ma machine.
			\subsection{Résultats}
				\paragraph*{}
					J'ai aussi réalisé le montage de test mais en utilisant l'ancien module \gls{MIPS} ce qui a permis de le comparer avec le nouveau module réalisé durant le stage. On remarque alors  que la plupart des informations détaillées (exemple: figures \ref{fig:GenDbg_GUI_Qt_Vue_code_Instruction_saut_non_conditionnel}, \ref{fig:GenDbg_GUI_Qt_Vue_code_Instruction_saut_conditionnel} et \ref{fig:GenDbg_GUI_Qt_Vue_code_Instruction_ecriture_memoire}) sont absentes ou erronées avec l'ancien module et que ce dernier suppose les instructions correctes.
				\paragraph*{}
					Le problème de supposer les instructions correctes apparait lorsqu'il y a des données présentes dans le code qui ne correspondent à aucune instruction, l'ancien module \gls{MIPS} retourne alors une instruction erronée. Par exemple pour la valeur ``\jcode{00 00 04 20}'', l'ancien module retourne ``\jcode{move \reg{zero}, \reg{zero}}'', ce qui est faux tandis que le nouveau module retourne ``\jcode{.byte 00, 00, 04, 20}'' car cela ne correspond à aucune instruction.
				\paragraph*{}
					J'ai aussi remarqué que l'ancien module MIPS ne permettait pas de réaliser l'assemblage de code, pour changer une instruction du programme débogué il était donc nécessaire de passer par un programme externe à GenDbg pour assembler l'instruction avant d'ensuite retourner sur GenDbg pour écrire la valeur de cette dernière dans le programme débogué.
				\paragraph*{}
					Finalement j'ai aussi testé le module pour les versions de \gls{MIPS} Little endian et Big Endian, mais aborder l'endianness nécessiterait une présentation beaucoup plus complète de l'architecture \gls{MIPS} qui présente des particularités sur ce point. De plus le traitement de l'endianness n'étant pas complètement normé dans GenDbg, le module a pour but principal le support MIPS qui est la version Big Endian. La version Little endian est elle nommée \acrshort{MIPSel} pour \acrlong{MIPSel} et est supportée par le module dans le cas où un swap des valeurs des registres est effectué par le stub a la lecture.
		\section{Difficultés}
			\paragraph*{}
				Les difficultés rencontrées ont été purement techniques, je vais en détailler uniquement une à titre d'exemple du type de problème rencontrés lors du développement du module.
			\paragraph*{}
				Capstone, tout comme GenDgb, utilise une enum pour identifier les différents registres, l'une des premières choses à faire a été de réaliser la correspondance entre les registres de Capstone et ceux de GenDbg. Pour cela j'ai réalisé des tableaux de correspondance et des fonctions de conversion dédiées afin de mettre a part, cette correspondance pour que lors d'une possible évolution des identifiants de Capstone ou GenDbg, le minimum de modifications soit nécessaire.
			\paragraph*{}
				La correspondance n'est pas toujours évidente a réaliser, prenons l'exemple du \gls{FCCR}. Le \gls{FCCR} (voir figure \ref{fig:MIPS_FCCR_register_format}) contient les 8 \gls{FCC} du \gls{FPU}, la valeur de ces \gls{FCC} est stockée sur les 8 bits de poids faible, un bit par \gls{FCC}, il est possible d'accéder aux \gls{FCC} individuellement avec \reg{fcc0/1/\ldots/7} ou à la totalité du registre avec \reg{25} (dans une instruction \gls{FPU}).
			\begin{figure}[H]
				\centering%
				\includegraphics[width=1\textwidth]{MIPS_FCCR_register_format}
				\caption{\acrshort{MIPS}: Format du registre \acrshort{FCCR}}%
				\label{fig:MIPS_FCCR_register_format}%
			\end{figure}
			\paragraph*{}
				Capstone définit un registre par bit (\jcode{MIPS\_REG\_FCC0/1/\ldots/7}) tandis que GenDbg ne définit qu'un registre (\jcode{MIPS\_FCCR}). Les représentations de Capstone et GenDbg sont donc toutes les deux valables. Ces dernières étant non modifiables, la correspondance que j'ai réalisée (tous les \gls{FCCR} de Capstone vers l'unique \gls{FCCR} de GenBdg) pourra mener à la perte d'information dans la représentation textuelle de certaines instructions \gls{FPU}.
			\paragraph*{}
				Le support des coprocesseurs (tel que le \gls{FPU}) n'étant pas un objectif du module pour le moment cela n'est pas un problème majeur. Le plus important pour le module étant les \gls{GPR} et les \gls{SPR} qui avaient une bonne correspondance entre Capstone et GenDbg.
		\section{Résultats}
			\paragraph*{}
				Comme vu avec les tests manuels, le nouveau module corrige les problèmes d'instructions erronées de l'ancien module et ajoute les informations détaillées qui manquaient. Une autre amélioration est l'ajout de l'assemblage des instructions avec Keystone, cette fonctionnalité étant totalement absente de l'ancien module, mais l'amélioration la plus importante est bien l'utilisation de Capstone qui vient réaliser le désassemblage MIPS qui était entièrement codé dans l'ancien module.
			\begin{figure}[H]
				\centering%
				\resizebox{0.7\textwidth}{!}{\import{figures/}{Lignes_code_module_MIPS.tex}}%
				\caption{Lignes de code: ancien module MIPS, nouveau module MIPS, tests et dépendances}%
				\label{fig:Lignes_code_module_MIPS}%
			\end{figure}
			\paragraph*{}
				Comme le montre la figure \ref{fig:Lignes_code_module_MIPS}, la quantité de code du nouveau module est beaucoup plus faible, ce qui simplifie drastiquement la maintenance du module. Cette diminution de la quantité de code vient majoritairement de l'utilisation de Capstone et Keystone qui comportent eux énormément de code mais ces derniers permettent une meilleure gestion des erreurs et surtout ne nécessitent pas d'être maintenu.
			\paragraph*{}
				Un autre avantage de l'utilisation de Capstone et Keystone est que le module profitera des améliorations apportées à ces derniers dans leurs futurs mise à jours, que ce soit des améliorations de performance ou le support des futures versions de l'\gls{ISA} \gls{MIPS}.
			\paragraph*{}
				Enfin, l'ajout de tests permet de fiabiliser le module mais aussi simplifie son maintien et son évolution, par exemple en s'assurant que les futures modifications ajoutées au module, que ce soit pour l'ajout de fonctionnalités ou les mises à jour de Capstone et Keystone, ne viennent pas introduire des comportements non voulus.
	\chapter{YaCo}\label{ch:yaco}
		\section{Compilation}
			\paragraph*{}
				Tout comme GenDbg, la compilation est gérée avec CMake et inclut toutes ces dépendances afin de ne pas dépendre d'une plateforme, d'un compilateur ou de librairies que l'utilisateur devrait au préalable installer. Une exception étant les tests d'intégration qui nécessitent d'avoir Python installé.
			\paragraph*{}
				Le processus de compilation commence par exécuter \gls{SWIG} avec ses fichiers de configuration qui spécifient les headers qui contiennent les fonctions et classes pour lesquelles il faut générer des bindings. \gls{SWIG} génère alors un fichier C++ et les bindings Python qui lui sont associés. Le fichier C++ généré par \gls{SWIG} sera ensuite compilé avec la partie C++ de YaCo pour générer une \gls{DLL}.
			\paragraph*{}
				YaCo est donc constitué une fois compilé du fichier plugin Python \file{yaco\_plugin.py} et d'un dossier qui contient toute l'implémentation Python ainsi que la librairie C++ et ses bindings Python. Un script permet de déployer YaCo dans l'installation de IDA en créant des liens symboliques vers les éléments de YaCo dans le dossier \folder{plugin} de IDA.
		\section{Les événements IDA}
			\subsection{Fonctionnement}
				\paragraph*{}
					La gestion interne de la base de code par IDA n'est pas connue, mais l'on peut interagir avec cette dernière par son \gls{API} afin d'obtenir des informations ou bien de la modifier. Mais ce qui nous intéresse ce sont les modifications faites par l'utilisateur, pour cela l'\gls{API} IDA permet d'enregistrer des ``hooks'' afin d’être prévenu de ces modifications.
				\begin{figure}[H]
					\centering%
					\resizebox{0.8\textwidth}{!}{\import{figures/}{YaCo_hooks1.tex}}%
					\caption{YaCo: fonctionnement des hooks}%
					\label{fig:YaCo_hooks1}%
				\end{figure}
				\paragraph*{}
					Dans YaCo, et comme représenté sur la figure \ref{fig:YaCo_hooks1}, les hooks sont gérés par la classe \jcode{Hooks} qui s'enregistre avec l'\gls{API} IDA pour recevoir les évènements des modifications de la base de code tel que la suppression d'une structure ou le renommage d'une fonction. À chaque évènement, l'adresse de la modification (ou l'id dans le cas des \textit{enum} et \textit{structs}) est enregistrée dans les hooks.
				\begin{figure}[H]
					\centering%
					\resizebox{0.8\textwidth}{!}{\import{figures/}{YaCo_hooks2.tex}}%
					\caption{YaCo: hooks, sauvegarde de la base}%
					\label{fig:YaCo_hooks2}%
				\end{figure}
				\paragraph*{}
					Lorsque l'utilisateur sauvegarde, IDA applique les modifications a son \gls{IDB} et envoie un événement aux hooks enregistrés. YaCo utilise alors les adresses stockées pour récupérer toutes les informations sur les zones modifiées dans un modèle qui est ensuite exporté en fichiers \gls{XML} avec un exporteur \gls{XML}.
			\subsection{Implémentation}
				\paragraph*{}
					Dans YaCo, les hooks sont gérés par la classe \jclass{Hooks}, cette dernière enregistre les hooks auprès d'IDA puis, à chaque évènement de modification de la base, enregistre les adresses des modifications. Pour enregistrer un hook avec l'\gls{API} IDA il faut utiliser la fonction \jfunc{hook\_to\_notification\_point} (voir \annexe{idaapi}) qui prend en paramètre une fonction de type \jfunc{hook\_cb\_t}:\\
					\lstinputlisting[language={[yaco]C}, style=magic_style, numbers=none]{code/hook_cb_t.c}
				\paragraph*{}
					Le premier paramètre (\jcode{user\_data}) est utilisé pour passer la classe \jclass{Hooks} à la fonction afin d'y ajouter l'adresse de la modification, le second paramètre (\jcode{notification\_code}) correspond a l'enum des évènements possibles pour le type d'évènements hooké (voir \annexe{idaapi}) et le dernier paramètre (\jcode{va}) contient les arguments de l'évènement (spécifiés dans la documentation).
				\paragraph*{}
					IDA permet d'écouter différents types d'évènements (voir l'enum \jclass{hook\_type\_t} dans l'\annexe{idaapi}), parmi ces évènements, les évènements IDP (module processeur) sont les plus généraux et regroupent souvent de nombreuses modifications dans un seul évènement, mais ils permettent de suivre certaines des modifications de la base de code. Tandis que les évènements IDB sont eux plus précis et permettent de suivre presque l'intégralité des modifications.
				\paragraph*{}
					Alors que la version Python des hooks utilisait certains évènements IDP car les évènements IDB était incomplets dans l'\gls{API} Python, la version C++ n'utilise elle que les évènements IDB car ces derniers sont beaucoup plus complets dans l'\gls{API} C++. Cela a permis le support de nouveaux évènements ainsi qu'une grande simplification du code.
				\paragraph*{}
					Pour ce qui est de l'export des modifications, lorsque la base est sauvegardée, YaCo utilise un système de modèles et exporteurs qui utilise un design pattern visiteur bien pensé, mais qui ne sera pas détaillé ici, cette parie étant déjà en C++. Ainsi à la réception de l'évènement de sauvegarde, les hooks, par ce système, exportent les informations sur les zones modifiées au format \gls{XML}, ces fichiers sont par la suite synchronisés par le repository.
			\subsection{Résultats}
				\p{Améliorations}
					Le fait de passer de l'\gls{API} Python a l'\gls{API} C++ plus complète a permis le support de nouveaux évènements, les plus notables étant tous ceux en rapport avec les segments tels que le changement de position, de taille, de nom, de flags ou même de couleur.
				\paragraph*{}
					Une amélioration très attendue de YaCo était la gestion du renommage des registres, or lors de la mise a jour de IDA vers sa version 7, des améliorations ont été apportées à l'\gls{API} dont l'ajout d'évènements pour le renommage des registres. Le portage a donc aussi été l'occasion d'ajouter le support de ces évènements à YaCo.
				\paragraph*{}
					Afin de permettre une évolutivité simple des hooks, j'ai ajouté à ces derniers l'analyse et le log de tous les évènements IDB de IDA afin que l'ajout du support de nouveaux évènements soit le plus simple possible.
				\paragraph*{}
					Le log des évènements permet de comprendre plus simplement ce qui s'est passé en cas de crash ou comportement anormal de YaCo mais permet aussi, lorsqu'une modification n'est pas prise en compte par YaCo, d'identifier facilement si un évènement IDA lui est associé et si cela est le cas, lequel.
				\p{Limitations}
					Certains évènements manquent toujours même avec l'\gls{API} C++ d'IDA, par exemple ceux relatifs à la modification des bookmarks, empêchant YaCo de gérer ces derniers pour le moment.
				\paragraph*{}
					On peut aussi noter les évènements aux comportements anormaux tels que celui du flag \textit{noret}, qui indique si une fonction retourne quelque chose ou non, dont la modification donne lieu à un évènement uniquement la première fois.
		\section{Le dépôt Git}
			\subsection{Fonctionnement}
				\p{Git}
					Git est un système de contrôle de versions distribuée, gratuit, et open-source conçu pour gérer le code source des petits aux très grands projets rapidement et efficacement. Il est très utilisé pour la gestion de tous type de projet informatique et sur des sites d'hébergement de code tel que GitHub, pour plus d'informations se référer au site git-scm\cite{GitSCM}. Un schéma représentant les déplacements de données des commandes essentielles est disponible en \annexe{gitcommands}.
				\p{Synchronisation}
					Après les modifications apportées aux fichiers \gls{XML} du dépôt Git, la classe \jclass{Repository}, qui gère le dépôt, prend la main pour synchroniser le dépôt local avec celui distant, dans le cas où ce dernier a été configuré. Prenons l'exemple ou la fonction \texttt{test\_function} a été renommée \texttt{new\_name\_1}.
				\begin{figure}[H]
					\centering%
					\resizebox{0.6\textwidth}{!}{\import{figures/}{YaCo_repository1.tex}}%
					\caption{YaCo: commit des modifications}%
					\label{fig:YaCo_repository1}%
				\end{figure}
				\paragraph*{}
					En reprenant les notations de la figure \ref{fig:YaCo_repository1}, le repository commence par créer un commit \texttt{M} sur la branche locale \texttt{master} qui contient les modifications apportées aux fichiers \gls{XML} des modifications. Commence ensuite la synchronisation avec le dépôt distant, pour cela, la branche master de ce dernier est fetch.
				\begin{figure}[H]
					\centering%
					\resizebox{0.9\textwidth}{!}{\import{figures/}{YaCo_repository2.tex}}%
					\caption{YaCo: fetch de la branche distante}%
					\label{fig:YaCo_repository2}%
				\end{figure}
				\paragraph*{}
					Une fois la branche master distante fetch (voir figure \ref{fig:YaCo_repository2}), on rebase les modifications locales (commit \texttt{M}) à la suite des modifications distantes (commit \texttt{E}), plusieurs cas sont alors possibles:
					\begin{itemize}
						\item Pas de modification distantes: rien ne se passe
						\item Des modifications sur des lignes différentes des lignes modifiées en local: git merge les modifications
						\item Des modifications d'éléments différents sur la même ligne ou des lignes proches (échec du merge automatique de git): utilisation du SmartMerger de YaCo qui va gérer le conflit
						\item Modification du même élément: on demande à l'utilisateur de choisir la version à garder
					\end{itemize}
				\begin{figure}[H]
					\centering
					\includegraphics[width=0.7\textwidth]{YaCo_conflict_view}
					\caption{YaCo: fenêtre de dialogue pour la résolution des conflits}
					\label{fig:YaCo_conflict_view}
				\end{figure}
				\paragraph*{}
					Toujours dans notre exemple, sur la branche distante la fonction \texttt{test\_function} a été renommée \texttt{new\_name\_2}, nous sommes donc dans le dernier cas, la fenêtre de dialogue visible sur la figure \ref{fig:YaCo_conflict_view} permet alors à l'utilisateur de choisir le nom de fonction à garder (\texttt{new\_name\_3} dans notre cas).
				\begin{figure}[H]
					\centering%
					\resizebox{0.9\textwidth}{!}{\import{figures/}{YaCo_repository3.tex}}%
					\caption{YaCo: push de la branche locale après le rebase}%
					\label{fig:YaCo_repository3}%
				\end{figure}
				\paragraph*{}
					Une fois le rebase opéré, dans notre exemple et comme visible sur la figure \ref{fig:YaCo_repository3}, un commit \texttt{M'} a été créé avec le renommage de la fonction \texttt{test\_function} en \texttt{new\_name\_3}. Les modifications sont ensuite push sur le dépôt distant.
				\paragraph*{}
					Après la synchronisation effectuée, les modifications des fichiers \gls{XML} sont chargées et appliquées à IDA afin que ce derniers prenne en compte les modifications issues du dépôt distant et donc des autres utilisateurs travaillant sur la base de code.
				\p{Force push}
					Il arrive que le dépôt Git, bien que maintenu par YaCo, se désynchronise avec l'\gls{IDB} local d'IDA, ça a par exemple été le cas lors de la mise à jour d'IDA vers sa version 7 qui a effectué une nouvelle analyse de mon \gls{IDB} de test sans lancer les plugins, dans ce cas-là, le menu graphique de YaCo permet de resynchroniser et push sa base.
				\begin{figure}[H]
					\centering%
					\resizebox{0.6\textwidth}{!}{\import{figures/}{YaCo_repository_sync_and_push.tex}}%
					\caption{YaCo: force push}%
					\label{fig:YaCo_repository_sync_and_push}%
				\end{figure}
				\paragraph*{}
					Pour cela et comme représenté sur la figure \ref{fig:YaCo_repository_sync_and_push}, le repository supprime l'ensemble des fichiers \gls{XML} ainsi que l'\gls{IDB} original du dépôt qu'il remplace par l'\gls{IDB} local d'IDA, rétablissant la synchronisation. Le dépôt git est ensuite force push, c'est-à-dire que la branche master locale vas remplacer la branche distante.
	%%% Bibliographie
	\nocite{*}
	\bibliographystyle{ieeetr-fr}
	\bibliography{references}
	%%% Lexique
	%\glsaddall
	%\printglossaries{}
	%printglossary{}
	\printglossary[type=\acronymtype,title=Lexique,toctitle=Lexique]{}\markboth{LEXIQUE}{}
	\chaptertoc{Annexes}\markboth{ANNEXES}{}
		\setcounter{section}{0}
		\renewcommand{\thesection}{\Alph{section}}
		\renewcommand{\theHsection}{appendixsection.\Alph{section}}
		\section{Organigramme de la DGA}\label{sec:organigrammedga}
			\begin{figure}[H]
				\centering
				\includegraphics[width=\textwidth]{Organigramme_DGA}
				\caption{Organigramme de la DGA\cite{OrganigrammeDGA}}
				\label{fig:Organigramme_DGA}
			\end{figure}
		\newpage\section{Hiérarchie des Ministères Français à VIM/VSE}\label{sec:hierarchieministereavim}
			\begin{figure}[H]
				\centering
				\resizebox{1.05\textwidth}{!}{\import{figures/}{Hierarchie_Ministeres_a_VIM.tex}}
				\caption{Hiérarchie des Ministères Français à VIM/VSE}
				\label{fig:Hierarchie_Ministeres_a_VIM}
			\end{figure}
		\newpage\section{GUI Qt de GenDbg}\label{sec:guiqtgendbg}
			\begin{figure}[H]
				\hspace*{-1cm}
				\centering
				\fbox{\includegraphics[width=1.1\textwidth]{GenDbg_GUI_Qt}}\\
				%\vspace*{1em}
				%\hspace*{-1cm}
				%\fbox{\resizebox{1.1\textwidth}{!}{\import{figures/}{GenDbg_GUI_Qt_Annotations.tex}}}
				\caption{\acrshort{GUI} Qt de GenDbg}
				\label{fig:GenDbg_GUI_Qt}
			\end{figure}
			\begin{figure}[H]
				\hspace*{-1cm}
				\centering
				\fbox{\resizebox{1.1\textwidth}{!}{\import{figures/}{GenDbg_GUI_Qt_Annotations.tex}}}
				\caption{\acrshort{GUI} Qt de GenDbg: lecture}
				\label{fig:GenDbg_GUI_Qt_Annotations}
			\end{figure}
		\newpage\section{GUI Qt de GenDbg: lecture de la vue code}\label{sec:guiqtgendbgvuecode}
			\begin{figure}[H]
				\hspace*{-1cm}
				\centering
				\resizebox{1.1\textwidth}{!}{\import{figures/}{GenDbg_GUI_Qt_Vue_code_Annotations.tex}}
				\caption{\acrshort{GUI} Qt de GenDbg: lecture de la vue code}
				\label{fig:GenDbg_GUI_Qt_Vue_code_Annotations}
			\end{figure}
		\newpage\section{Dépendances de certains éléments de GenDbg}\label{sec:gendbgdependancescompilationsimplifiees}
			\begin{figure}[H]
				\hspace*{-1cm}
				\centering
				\resizebox{1.1\textwidth}{!}{\import{figures/}{GenDbg_dependances_compilation_simplifiees.tex}}
				\caption{Représentation simplifiée des dépendances de certains éléments de GenDbg}
				\label{fig:GenDbg_dependances_compilation_simplifiees}
				\vspace*{-2cm}
			\end{figure}
		\newpage\section{Détail de AsmModuleInfo\_T}\label{sec:detailasmmoduleinfot}
			\lstinputlisting[language={[gendbg]C}, style=magic_style]{code/AsmModuleInfo_T.c}
			\begin{itemize}
				\item \texttt{Version}: version du module (2)
				\item \texttt{Architecture}: architecture (\gls{MIPS})
				\item \texttt{szCellInBits}: taille de cellule (8 bits)
				\item \texttt{szMaxInstructionInCell}: taille max d'une instruction (32 bits, 4 cellules)
				\item \texttt{TblDataType}: type de données utilisées (byte, halfword, word, doubleword)
				\item \texttt{TblGroupRegister}: groupes de registres (\gls{GPR}32, \gls{GPR}64, \gls{SPR}32, \ldots)
				\item \texttt{TblAddressType}: types d'adresses (virtual, physical)
				\item \texttt{TblAddressSpace}: espaces d'adressage (espace unique sur \gls{MIPS})
				\item \texttt{TblBank}: modes du processeur (absent sur \gls{MIPS})
				\item \texttt{CPUCtxSyntaxHelp}: aide utilisateur pour la syntaxe du contexte CPU
				\item \texttt{AddressSyntaxHelp}: aide utilisateur pour la syntaxe des adresses
				\item \texttt{DataSyntaxHelp}: aide utilisateur pour la syntaxe des données
				\item \texttt{ConditionSyntaxHelp}: aide utilisateur pour la syntaxe des conditions
				\item \texttt{FunctionTbl}: liste des fonctions de rappel du module
			\end{itemize}
			\paragraph*{}
				\texttt{FunctionTbl} a pour taille \texttt{AsmModule\_LastFnIdx} car il contient les pointeur sur toutes les fonctions de rappel de module listé dans \jclass{AsmModuleFnIdx\_T} (voir \annexe{asmmodulefnidxt}).
		\newpage\section{AsmModuleFnIdx\_T}\label{sec:asmmodulefnidxt}
			\lstinputlisting[language={[gendbg]C}, style=magic_style]{code/AsmModuleFnIdx_T.c}
		\newpage\section{Fonctions de rappel des modules ASM}\label{sec:fonctionsrappelmodulesasm}
			\lstinputlisting[language={[gendbg]C}, style=magic_style]{code/AsmModuleAPI.c}
		\newpage\section{Structures de Capstone}\label{sec:structurescapstone}
			\lstinputlisting[language={[gendbg]C}, style=magic_style]{code/cs_insn.c}
			\lstinputlisting[language={[gendbg]C}, style=magic_style]{code/cs_detail.c}
			\lstinputlisting[language={[gendbg]C}, style=magic_style]{code/cs_mips.c}
			\lstinputlisting[language={[gendbg]C}, style=magic_style]{code/cs_mips_op.c}
			\lstinputlisting[language={[gendbg]C}, style=magic_style]{code/mips_op_mem.c}
		\newpage\section{IDA 7 GUI}\label{sec:ida7gui}
			\begin{figure}[H]
				\hspace*{-0.5cm}
				\centering
				\fbox{\includegraphics[width=1.1\textwidth]{IDA7_Vue_texte}}
				\caption{IDA 7 \acrshort{GUI}: Vue texte}
				\label{fig:IDA7_Vue_texte}
			\end{figure}
			\begin{figure}[H]
				\hspace*{-0.5cm}
				\centering
				\fbox{\includegraphics[width=1.1\textwidth]{IDA7_Vue_graphe}}
				\caption{IDA 7 \acrshort{GUI}: Vue graphe}
				\label{fig:IDA7_Vue_graphe}
			\end{figure}
		\newpage\section{Extraits de l'API IDA}\label{sec:idaapi}
			\lstinputlisting[language={[yaco]C}, style=magic_style, numbers=none]{code/hook_to_notification_point_unhook_to_notification_point.c}
			\lstinputlisting[language={[yaco]C}, style=magic_style, numbers=none]{code/hook_type_t.c}
\end{document}
